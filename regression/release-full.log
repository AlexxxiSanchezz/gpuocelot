INFO     Reading in test file /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/regression/full.level
INFO      Found the following tests:
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLexer
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestParser
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestEmulator
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestInstructions
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestKernels
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDataflowGraph
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMInstructions
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXToLLVMTranslator
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMKernels
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaMalloc
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTexture2D
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTextureArray
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaGlobals
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDeviceSwitching
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaSequence
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCalVectorScale
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXAssembly
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestFunctionCall
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestIndirectFunctionCall
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestExternalFunctions
INFO     ==== INDIVIDUAL TEST RESULTS ====

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDeviceSwitching 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMInstructions 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestFunctionCall 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTexture2D 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMInstructions
INFO     Test completed in 0.0470569133759 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLLVMInstructions

Description: A test for the assembly code generation and automatic 
             verfication of individual LLVM instructions. Test Points: 1) For each 
             instruction, generate several assembly strings using the 
             instruction's toString method, make sure that these pass the valid() 
             check, compare to references from the LLVM manual.


Test Seed : 1335814028
Test time : 0.00095439

Status :  Checked instruction "<result> = add i32 4, %var"
Add Instruction Passed
 Checked instruction "%ptr = alloca i32"
 Checked instruction "%ptr = alloca i32, i32 4"
 Checked instruction "%ptr = alloca i32, i32 4, align 1024"
 Checked instruction "%ptr = alloca i32, align 1024"
Alloca Instruction Passed
 Checked instruction "<result> = and i32 4, %var"
 Checked instruction "<result> = and i32 15, 40"
 Checked instruction "<result> = and i32 4, 8"
And Instruction Passed
 Checked instruction "<result> = ashr i32 4, 1"
 Checked instruction "<result> = ashr i8 -2, 1"
 Checked instruction "<result> = ashr < 2 x i32 > < i32 -2, i32 4 >, < i32 1, i32 3 >"
Ashr Instruction Passed
 Checked instruction "%X = bitcast i8 -1 to i8"
 Checked instruction "%Z = bitcast < 2 x i32 > %V to i64"
Bitcast Instruction Passed
 Checked instruction "br i1 %cond, label %IfEqual, label %IfUnequal"
Br Instruction Passed
 Checked instruction "%retval = call i32 @test(i32 %argc)"
 Checked instruction "call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)"
 Checked instruction "%X = tail call i32 @foo()"
 Checked instruction "%Y = tail call fastcc i32 @foo()"
 Checked instruction "call void @foo(i8 97 signext)"
 Checked instruction "%r = call %struct.A @foo()"
 Checked instruction "call void @foo() noreturn"
 Checked instruction "%ZZ = call zeroext i32 @bar()"
Call Instruction Passed
 Checked instruction "%result = extractelement < 4 x i32 > %vec, i32 0"
Extractelement Instruction Passed
 Checked instruction "%result = extractvalue { i32, float } %agg, 0"
Extractvalue Instruction Passed
 Checked instruction "<result> = fadd float 0x4010000000000000, %var"
Fadd Instruction Passed
 Checked instruction "<result> = fcmp oeq float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp one float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp olt float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp ueq float 0x3ff0000000000000, 0x4000000000000000"
Fcmp Instruction Passed
 Checked instruction "<result> = fdiv float 0x4010000000000000, %var"
Fdiv Instruction Passed
 Checked instruction "<result> = fmul float 0x4010000000000000, %var"
Fmul Instruction Passed
 Checked instruction "%X = fpext float 0x400921cac0000000 to double"
 Checked instruction "%Y = fpext float 0x3ff0000000000000 to float"
Fpext Instruction Passed
 Checked instruction "%X = fptosi double 0xc05ec00000000000 to i32"
Fptosi Instruction Passed
 Checked instruction "%X = fptoui double 0x405ec00000000000 to i32"
Fptoui Instruction Passed
 Checked instruction "%X = fptrunc double 0x405ec00000000000 to float"
Fptrunc Instruction Passed
 Checked instruction "free [ 4 x i8 ]* %array"
Free Instruction Passed
 Checked instruction "<result> = frem float 0x4010000000000000, %var"
Frem Instruction Passed
 Checked instruction "<result> = fsub float 0x0, %val"
Fsub Instruction Passed
 Checked instruction "%vptr = getelementptr { i32, < 2 x i8 > }* %svptr, i32 0, i32 1, i32 1"
 Checked instruction "%eptr = getelementptr [ 12 x i8 ]* %aptr, i32 0, i32 1"
Getelementptr Instruction Passed
 Checked instruction "<result> = icmp ne float* %X, %X"
Icmp Instruction Passed
 Checked instruction "%result = insertelement < 4 x i32 > %vec, i32 1, i32 0"
Insertelement Instruction Passed
 Checked instruction "%result = insertvalue { i32, float } %agg, i32 1, 0"
Insertvalue Instruction Passed
 Checked instruction "%Y = inttoptr i64 0 to i32*"
Inttoptr Instruction Passed
 Checked instruction "%retval = invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup"
Invoke Instruction Passed
 Checked instruction "%val = load i32* %ptr"
Load Instruction Passed
 Checked instruction "<result> = lshr i8 -2, 1"
Lshr Instruction Passed
 Checked instruction "%array2 = malloc [ 12 x i8 ], i32 %size"
Malloc Instruction Passed
 Checked instruction "<result> = mul i32 4, %var"
Mul Instruction Passed
 Checked instruction "<result> = or i32 15, 40"
Or Instruction Passed
 Checked instruction "%indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]"
Phi Instruction Passed
 Checked instruction "%Y = ptrtoint i32* %x to i64"
Prtoint Instruction Passed
 Checked instruction "ret void"
Ret Instruction Passed
 Checked instruction "<result> = sdiv i32 4, %var"
Sdiv Instruction Passed
 Checked instruction "%X = select i1 1, i8 17, i8 42"
Select Instruction Passed
 Checked instruction "%X = sext i8 -1 to i16"
Sext Instruction Passed
 Checked instruction "<result> = shl i32 1, 32"
Shl Instruction Passed
 Checked instruction "%result = shufflevector < 4 x i32 > %v1, < 4 x i32 > %v2, < 8 x i32 > < i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >"
ShuffleVector Instruction Passed
 Checked instruction "%X = sitofp i32 257 to float"
Sitofp Instruction Passed
 Checked instruction "<result> = srem i32 4, %var"
Srem Instruction Passed
 Checked instruction "store i32 3, i32* %ptr"
Store Instruction Passed
 Checked instruction "<result> = sub i32 4, %var"
Sub Instruction Passed
 Checked instruction "switch i32 %val, label %otherwise [ i32 0, label %onzero i32 1, label %onone i32 2, label %ontwo ]"
Switch Instruction Passed
 Checked instruction "%Y = trunc i32 123 to i1"
Trunc Instruction Passed
 Checked instruction "<result> = udiv i32 4, %var"
Udiv Instruction Passed
 Checked instruction "%Y = uitofp i8 -1 to double"
Uitofp Instruction Passed
 Checked instruction "unreachable"
Unreachable Instruction Passed
 Checked instruction "unwind"
Unwind Instruction Passed
 Checked instruction "<result> = urem i32 4, %var"
Urem Instruction Passed
 Checked instruction "%tmp = va_arg i8** %ap, i32"
VarArg Instruction Passed
 Checked instruction "<result> = xor i32 -1, %V"
Xor Instruction Passed
 Checked instruction "%X = zext i32 257 to i64"
Zext Instruction Passed



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestInstructions 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestFunctionCall
INFO     Test completed in 0.0487010478973 seconds
INFO      It produced the following output:
TestFunctionCall: ocelot/executive/implementation/DynamicTranslationCache.cpp:1027: void setupCallTargets(ir::PTXKernel&, const executive::DynamicTranslationCache&): Assertion `0 && "arbitrary function calls not yet supported"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaSequence 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDeviceSwitching
INFO     Test completed in 0.065682888031 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestDeviceSwitching

Description: A unit test for the ability of the CUDA runtime to switch 
             between devices and use multiple threads Test Points: 1) In a single 
             threaded application, iterate across all devices launching the same 
             simple kernel each time 2) Test context migration support in 
             ocelot. Iterate across all devices, launching a simple kernel that 
             updates shared variable. Use the context switch mechanism to 
             migrate the shared data. 3) Test multi-threading support. Launch one 
             host thread to allocate memory, pass pointers to worker 
             threads, each of which should launch independent kernels in 
             parallel.


Test Seed : 1335814028
Test time : 0.0100336

Status : Test Point 1 Passed
Test Point 2 Passed
Test Point 3 Passed



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXToLLVMTranslator -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTexture2D
INFO     Test completed in 0.0837638378143 seconds
INFO      It produced the following output:
Instruction does not dominate all uses!
  %r1.t1 = load i32* %rt6.t1, align 4
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
Instruction does not dominate all uses!
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
Instruction does not dominate all uses!
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
Instruction does not dominate all uses!
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
Instruction does not dominate all uses!
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
Instruction does not dominate all uses!
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
  %rt25 = zext i32 %r18.extracted.t0 to i64
Instruction does not dominate all uses!
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
Instruction does not dominate all uses!
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
Instruction does not dominate all uses!
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
Instruction does not dominate all uses!
  %rt25 = zext i32 %r18.extracted.t0 to i64
  %r19 = mul i64 %rt25, 4
Instruction does not dominate all uses!
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
  %r19.t3 = mul i64 %rt25.t3, 4
Instruction does not dominate all uses!
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
  %r19.t2 = mul i64 %rt25.t2, 4
Instruction does not dominate all uses!
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
  %r19.t1 = mul i64 %rt25.t1, 4
Instruction does not dominate all uses!
  %r19 = mul i64 %rt25, 4
  %r20 = add i64 %r0, %r19
Instruction does not dominate all uses!
  %r19.t3 = mul i64 %rt25.t3, 4
  %r20.t3 = add i64 %r0.t3, %r19.t3
Instruction does not dominate all uses!
  %r19.t2 = mul i64 %rt25.t2, 4
  %r20.t2 = add i64 %r0.t2, %r19.t2
Instruction does not dominate all uses!
  %r19.t1 = mul i64 %rt25.t1, 4
  %r20.t1 = add i64 %r0.t1, %r19.t1
Instruction does not dominate all uses!
  %r20 = add i64 %r0, %r19
  %rt26 = inttoptr i64 %r20 to float*
Instruction does not dominate all uses!
  %r20.t3 = add i64 %r0.t3, %r19.t3
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
Instruction does not dominate all uses!
  %r20.t2 = add i64 %r0.t2, %r19.t2
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
Instruction does not dominate all uses!
  %r20.t1 = add i64 %r0.t1, %r19.t1
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
Instruction does not dominate all uses!
  %rt26 = inttoptr i64 %r20 to float*
  store float %r14, float* %rt26, align 4
Instruction does not dominate all uses!
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
  store float %r14.t3, float* %rt26.t3, align 4
Instruction does not dominate all uses!
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
  store float %r14.t2, float* %rt26.t2, align 4
Instruction does not dominate all uses!
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
  store float %r14.t1, float* %rt26.t1, align 4
Broken module found, verification continues.
verification failed for translated function for _Z6kernelPfii : ""
LLVMDynamicTranslationCache.cpp:1244:

define internal void @_subkernel__Z6kernelPfii_1_opt1_ws4(%LLVMContext* %__ctaContext) nounwind align 1 {
SchedulerEntry:
  %0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %threadId.x.t0 = load i32* %0
  %1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %threadId.y.t0 = load i32* %1
  %2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 2
  %threadId.z.t0 = load i32* %2
  %3 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %blockDim.x.t0 = load i32* %3
  %4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %blockDim.y.t0 = load i32* %4
  %5 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 2
  %blockDim.z.t0 = load i32* %5
  %6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %blockId.x.t0 = load i32* %6
  %7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %blockId.y.t0 = load i32* %7
  %8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 2
  %blockId.z.t0 = load i32* %8
  %9 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 0
  %gridDim.x.t0 = load i32* %9
  %10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 1
  %gridDim.y.t0 = load i32* %10
  %11 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 2
  %gridDim.z.t0 = load i32* %11
  %localPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %localPtr.t0 = load i8** %localPtrPtr.t0
  %sharedPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5
  %sharedPtr.t0 = load i8** %sharedPtrPtr.t0
  %constPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 6
  %constPtr.t0 = load i8** %constPtrPtr.t0
  %paramPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 7
  %paramPtr.t0 = load i8** %paramPtrPtr.t0
  %argumentPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %argumentPtr.t0 = load i8** %argumentPtrPtr.t0
  %metadataPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 9
  %metadataPtr.t0 = load i8** %metadataPtrPtr.t0
  %integerTexture = alloca i32, i32 4, align 16
  %floatingPointTexture = alloca float, i32 4, align 16
  %bitcast = bitcast i8* %localPtr.t0 to i32*
  %encodedResumePoint = load i32* %bitcast
  %resumePoint = and i32 %encodedResumePoint, 65535
  %12 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 0
  %threadId.x.t1 = load i32* %12
  %13 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 1
  %threadId.y.t1 = load i32* %13
  %14 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 2
  %threadId.z.t1 = load i32* %14
  %15 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 0
  %blockDim.x.t1 = load i32* %15
  %16 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 1
  %blockDim.y.t1 = load i32* %16
  %17 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 2
  %blockDim.z.t1 = load i32* %17
  %18 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 0
  %blockId.x.t1 = load i32* %18
  %19 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 1
  %blockId.y.t1 = load i32* %19
  %20 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 2
  %blockId.z.t1 = load i32* %20
  %21 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 0
  %gridDim.x.t1 = load i32* %21
  %22 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 1
  %gridDim.y.t1 = load i32* %22
  %23 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 2
  %gridDim.z.t1 = load i32* %23
  %localPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 4
  %localPtr.t1 = load i8** %localPtrPtr.t1
  %sharedPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 5
  %sharedPtr.t1 = load i8** %sharedPtrPtr.t1
  %constPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 6
  %constPtr.t1 = load i8** %constPtrPtr.t1
  %paramPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 7
  %paramPtr.t1 = load i8** %paramPtrPtr.t1
  %argumentPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 8
  %argumentPtr.t1 = load i8** %argumentPtrPtr.t1
  %metadataPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 9
  %metadataPtr.t1 = load i8** %metadataPtrPtr.t1
  %24 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 0
  %threadId.x.t2 = load i32* %24
  %25 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 1
  %threadId.y.t2 = load i32* %25
  %26 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 2
  %threadId.z.t2 = load i32* %26
  %27 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 0
  %blockDim.x.t2 = load i32* %27
  %28 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 1
  %blockDim.y.t2 = load i32* %28
  %29 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 2
  %blockDim.z.t2 = load i32* %29
  %30 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 0
  %blockId.x.t2 = load i32* %30
  %31 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 1
  %blockId.y.t2 = load i32* %31
  %32 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 2
  %blockId.z.t2 = load i32* %32
  %33 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 0
  %gridDim.x.t2 = load i32* %33
  %34 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 1
  %gridDim.y.t2 = load i32* %34
  %35 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 2
  %gridDim.z.t2 = load i32* %35
  %localPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 4
  %localPtr.t2 = load i8** %localPtrPtr.t2
  %sharedPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 5
  %sharedPtr.t2 = load i8** %sharedPtrPtr.t2
  %constPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 6
  %constPtr.t2 = load i8** %constPtrPtr.t2
  %paramPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 7
  %paramPtr.t2 = load i8** %paramPtrPtr.t2
  %argumentPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 8
  %argumentPtr.t2 = load i8** %argumentPtrPtr.t2
  %metadataPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 9
  %metadataPtr.t2 = load i8** %metadataPtrPtr.t2
  %36 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 0
  %threadId.x.t3 = load i32* %36
  %insert.threadId.x.t0.vec = insertelement <4 x i32> undef, i32 %threadId.x.t0, i32 0
  %insert.threadId.x.t1.vec = insertelement <4 x i32> %insert.threadId.x.t0.vec, i32 %threadId.x.t1, i32 1
  %insert.threadId.x.t2.vec = insertelement <4 x i32> %insert.threadId.x.t1.vec, i32 %threadId.x.t2, i32 2
  %insert.threadId.x.t3.vec = insertelement <4 x i32> %insert.threadId.x.t2.vec, i32 %threadId.x.t3, i32 3
  %37 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 1
  %threadId.y.t3 = load i32* %37
  %insert.threadId.y.t0.vec = insertelement <4 x i32> undef, i32 %threadId.y.t0, i32 0
  %insert.threadId.y.t1.vec = insertelement <4 x i32> %insert.threadId.y.t0.vec, i32 %threadId.y.t1, i32 1
  %insert.threadId.y.t2.vec = insertelement <4 x i32> %insert.threadId.y.t1.vec, i32 %threadId.y.t2, i32 2
  %insert.threadId.y.t3.vec = insertelement <4 x i32> %insert.threadId.y.t2.vec, i32 %threadId.y.t3, i32 3
  %38 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 2
  %threadId.z.t3 = load i32* %38
  %39 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 0
  %blockDim.x.t3 = load i32* %39
  %insert.blockDim.x.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.x.t0, i32 0
  %insert.blockDim.x.t1.vec = insertelement <4 x i32> %insert.blockDim.x.t0.vec, i32 %blockDim.x.t1, i32 1
  %insert.blockDim.x.t2.vec = insertelement <4 x i32> %insert.blockDim.x.t1.vec, i32 %blockDim.x.t2, i32 2
  %insert.blockDim.x.t3.vec = insertelement <4 x i32> %insert.blockDim.x.t2.vec, i32 %blockDim.x.t3, i32 3
  %40 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 1
  %blockDim.y.t3 = load i32* %40
  %insert.blockDim.y.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.y.t0, i32 0
  %insert.blockDim.y.t1.vec = insertelement <4 x i32> %insert.blockDim.y.t0.vec, i32 %blockDim.y.t1, i32 1
  %insert.blockDim.y.t2.vec = insertelement <4 x i32> %insert.blockDim.y.t1.vec, i32 %blockDim.y.t2, i32 2
  %insert.blockDim.y.t3.vec = insertelement <4 x i32> %insert.blockDim.y.t2.vec, i32 %blockDim.y.t3, i32 3
  %41 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 2
  %blockDim.z.t3 = load i32* %41
  %42 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 0
  %blockId.x.t3 = load i32* %42
  %insert.blockId.x.t0.vec = insertelement <4 x i32> undef, i32 %blockId.x.t0, i32 0
  %insert.blockId.x.t1.vec = insertelement <4 x i32> %insert.blockId.x.t0.vec, i32 %blockId.x.t1, i32 1
  %insert.blockId.x.t2.vec = insertelement <4 x i32> %insert.blockId.x.t1.vec, i32 %blockId.x.t2, i32 2
  %insert.blockId.x.t3.vec = insertelement <4 x i32> %insert.blockId.x.t2.vec, i32 %blockId.x.t3, i32 3
  %43 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 1
  %blockId.y.t3 = load i32* %43
  %insert.blockId.y.t0.vec = insertelement <4 x i32> undef, i32 %blockId.y.t0, i32 0
  %insert.blockId.y.t1.vec = insertelement <4 x i32> %insert.blockId.y.t0.vec, i32 %blockId.y.t1, i32 1
  %insert.blockId.y.t2.vec = insertelement <4 x i32> %insert.blockId.y.t1.vec, i32 %blockId.y.t2, i32 2
  %insert.blockId.y.t3.vec = insertelement <4 x i32> %insert.blockId.y.t2.vec, i32 %blockId.y.t3, i32 3
  %44 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 2
  %blockId.z.t3 = load i32* %44
  %45 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 0
  %gridDim.x.t3 = load i32* %45
  %46 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 1
  %gridDim.y.t3 = load i32* %46
  %47 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 2
  %gridDim.z.t3 = load i32* %47
  %localPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 4
  %localPtr.t3 = load i8** %localPtrPtr.t3
  %sharedPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 5
  %sharedPtr.t3 = load i8** %sharedPtrPtr.t3
  %constPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 6
  %constPtr.t3 = load i8** %constPtrPtr.t3
  %paramPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 7
  %paramPtr.t3 = load i8** %paramPtrPtr.t3
  %argumentPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 8
  %argumentPtr.t3 = load i8** %argumentPtrPtr.t3
  %metadataPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 9
  %metadataPtr.t3 = load i8** %metadataPtrPtr.t3
  switch i32 %resumePoint, label %"$BB_1_0002" [
  ]

"$BB_1_0002":                                     ; preds = %SchedulerEntry
  %rt2 = bitcast i8* %argumentPtr.t0 to i64*
  %rt2.t3 = bitcast i8* %argumentPtr.t3 to i64*
  %rt2.t2 = bitcast i8* %argumentPtr.t2 to i64*
  %rt2.t1 = bitcast i8* %argumentPtr.t1 to i64*
  %r0 = load i64* %rt2, align 8
  %r0.t3 = load i64* %rt2.t3, align 8
  %r0.t2 = load i64* %rt2.t2, align 8
  %r0.t1 = load i64* %rt2.t1, align 8
  %rt3 = getelementptr i8* %argumentPtr.t0, i32 8
  %rt3.t3 = getelementptr i8* %argumentPtr.t3, i32 8
  %rt3.t2 = getelementptr i8* %argumentPtr.t2, i32 8
  %rt3.t1 = getelementptr i8* %argumentPtr.t1, i32 8
  %rt6 = bitcast i8* %rt3 to i32*
  %rt6.t3 = bitcast i8* %rt3.t3 to i32*
  %rt6.t2 = bitcast i8* %rt3.t2 to i32*
  %rt6.t1 = bitcast i8* %rt3.t1 to i32*
  %r1 = load i32* %rt6, align 4
  %r1.t3 = load i32* %rt6.t3, align 4
  %insert.r1.vec = insertelement <4 x i32> undef, i32 %r1, i32 0
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
  %r1.t2 = load i32* %rt6.t2, align 4
  %r1.t1 = load i32* %rt6.t1, align 4
  %rt13.vec = mul <4 x i32> %insert.blockDim.x.t3.vec, %insert.blockId.x.t3.vec
  %r6.vec = add <4 x i32> %insert.threadId.x.t3.vec, %rt13.vec
  %r6.extracted.t3 = extractelement <4 x i32> %r6.vec, i32 3
  %r6.extracted.t2 = extractelement <4 x i32> %r6.vec, i32 2
  %r6.extracted.t1 = extractelement <4 x i32> %r6.vec, i32 1
  %r6.extracted.t0 = extractelement <4 x i32> %r6.vec, i32 0
  %rt20.vec = mul <4 x i32> %insert.blockDim.y.t3.vec, %insert.blockId.y.t3.vec
  %r10.vec = add <4 x i32> %insert.threadId.y.t3.vec, %rt20.vec
  %r10.extracted.t3 = extractelement <4 x i32> %r10.vec, i32 3
  %r10.extracted.t2 = extractelement <4 x i32> %r10.vec, i32 2
  %r10.extracted.t1 = extractelement <4 x i32> %r10.vec, i32 1
  %r10.extracted.t0 = extractelement <4 x i32> %r10.vec, i32 0
  %r11 = uitofp i32 %r6.extracted.t0 to float
  %r11.t3 = uitofp i32 %r6.extracted.t3 to float
  %r11.t2 = uitofp i32 %r6.extracted.t2 to float
  %r11.t1 = uitofp i32 %r6.extracted.t1 to float
  %r12 = uitofp i32 %r10.extracted.t0 to float
  %r12.t3 = uitofp i32 %r10.extracted.t3 to float
  %r12.t2 = uitofp i32 %r10.extracted.t2 to float
  %r12.t1 = uitofp i32 %r10.extracted.t1 to float
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11, float %r12)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t3, float %r12.t3)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t2, float %r12.t2)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t1, float %r12.t1)
  %r14 = load float* %floatingPointTexture
  %r14.t3 = load float* %floatingPointTexture
  %r14.t2 = load float* %floatingPointTexture
  %r14.t1 = load float* %floatingPointTexture
  %rt21 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t3 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t2 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t1 = getelementptr float* %floatingPointTexture, i32 1
  %r15 = load float* %rt21
  %r15.t3 = load float* %rt21.t3
  %r15.t2 = load float* %rt21.t2
  %r15.t1 = load float* %rt21.t1
  %rt22 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t3 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t2 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t1 = getelementptr float* %floatingPointTexture, i32 2
  %r16 = load float* %rt22
  %r16.t3 = load float* %rt22.t3
  %r16.t2 = load float* %rt22.t2
  %r16.t1 = load float* %rt22.t1
  %rt23 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t3 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t2 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t1 = getelementptr float* %floatingPointTexture, i32 3
  %r17 = load float* %rt23
  %r17.t3 = load float* %rt23.t3
  %r17.t2 = load float* %rt23.t2
  %r17.t1 = load float* %rt23.t1
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
  %rt25 = zext i32 %r18.extracted.t0 to i64
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
  %r19 = mul i64 %rt25, 4
  %r19.t3 = mul i64 %rt25.t3, 4
  %r19.t2 = mul i64 %rt25.t2, 4
  %r19.t1 = mul i64 %rt25.t1, 4
  %r20 = add i64 %r0, %r19
  %r20.t3 = add i64 %r0.t3, %r19.t3
  %r20.t2 = add i64 %r0.t2, %r19.t2
  %r20.t1 = add i64 %r0.t1, %r19.t1
  %rt26 = inttoptr i64 %r20 to float*
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
  store float %r14, float* %rt26, align 4
  store float %r14.t3, float* %rt26.t3, align 4
  store float %r14.t2, float* %rt26.t2, align 4
  store float %r14.t1, float* %rt26.t1, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002"
  ret void
}


error on subkernel: _Z_ocelotTranslated__subkernel__Z6kernelPfii_1
 specialization: _subkernel__Z6kernelPfii_1_opt1_ws4
TestCudaTexture2D: ocelot/executive/implementation/DynamicTranslationCache.cpp:1253: void cloneAndOptimizeTranslation(executive::DynamicTranslationCache::TranslatedKernel&, executive::DynamicTranslationCache::TranslatedSubkernel&, executive::DynamicTranslationCache::SubkernelId, executive::DynamicTranslationCache::Translation*, int, translator::Translator::OptimizationLevel, unsigned int, bool): Assertion `0 && "due to broken LLVM translation"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLexer -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestInstructions
INFO     Test completed in 0.0502169132233 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestInstructions

Description: 


Test Seed : 1335814028
Test time : 0.00063324

Status : Test output:
Accessors test passed.
pass: load and store instructions
Abs test passed.
pass: arithmetic instructions
pass: exotic arithmetic instructions
pass: floating-point instructions
pass: logical instructions
pass: comparison instructions
pass: predicated Add and Ld isntructions



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestIndirectFunctionCall 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXToLLVMTranslator
INFO     Test completed in 0.0356349945068 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestPTXToLLVMTranslator

Description: This is a basic test that just tries to get through a 
             translation successfully of as many PTX programs as possible Test 
             Points: 1) Scan for all PTX files in a directory, try to 
             translate them.


Test Seed : 1335814028
Test time : 1.57356e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTextureArray 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaSequence
INFO     Test completed in 0.0717790126801 seconds
INFO      It produced the following output:
Instruction does not dominate all uses!
  %r22.t1 = phi i32 [ %r20.t1, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t1, %"$BB_1_0002" ]
  %insert.r22.t1.vec = insertelement <4 x i32> %insert.r22.vec, i32 %r22.t1, i32 1
Instruction does not dominate all uses!
  %insert.r22.t1.vec = insertelement <4 x i32> %insert.r22.vec, i32 %r22.t1, i32 1
  %insert.r22.t2.vec = insertelement <4 x i32> %insert.r22.t1.vec, i32 %r22.t2, i32 2
Instruction does not dominate all uses!
  %insert.r22.t2.vec = insertelement <4 x i32> %insert.r22.t1.vec, i32 %r22.t2, i32 2
  %insert.r22.t3.vec = insertelement <4 x i32> %insert.r22.t2.vec, i32 %r22.t3, i32 3
PHI nodes not grouped at top of basic block!
  %r22.t2 = phi i32 [ %r20.t2, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t2, %"$BB_1_0002" ]
label %"$BB_1_0004"
Instruction does not dominate all uses!
  %insert.r22.t3.vec = insertelement <4 x i32> %insert.r22.t2.vec, i32 %r22.t3, i32 3
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
Instruction does not dominate all uses!
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
  %r23.extracted.t3 = extractelement <4 x i32> %r23.vec, i32 3
Instruction does not dominate all uses!
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
  %r23.extracted.t2 = extractelement <4 x i32> %r23.vec, i32 2
Instruction does not dominate all uses!
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
  %r23.extracted.t1 = extractelement <4 x i32> %r23.vec, i32 1
Instruction does not dominate all uses!
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
  %r23.extracted.t0 = extractelement <4 x i32> %r23.vec, i32 0
Instruction does not dominate all uses!
  %r22.t2 = phi i32 [ %r20.t2, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t2, %"$BB_1_0002" ]
  %rt65.t2 = sext i32 %r22.t2 to i64
Instruction does not dominate all uses!
  %rt65.t2 = sext i32 %r22.t2 to i64
  %r24.t2 = mul i64 %rt65.t2, 4
Instruction does not dominate all uses!
  %r24.t2 = mul i64 %rt65.t2, 4
  %r25.t2 = add i64 %r21.t2, %r24.t2
Instruction does not dominate all uses!
  %r25.t2 = add i64 %r21.t2, %r24.t2
  %rt66.t2 = inttoptr i64 %r25.t2 to i32*
Instruction does not dominate all uses!
  %r23.extracted.t0 = extractelement <4 x i32> %r23.vec, i32 0
  store i32 %r23.extracted.t0, i32* %rt66, align 4
Instruction does not dominate all uses!
  %r23.extracted.t3 = extractelement <4 x i32> %r23.vec, i32 3
  store i32 %r23.extracted.t3, i32* %rt66.t3, align 4
Instruction does not dominate all uses!
  %r23.extracted.t2 = extractelement <4 x i32> %r23.vec, i32 2
  store i32 %r23.extracted.t2, i32* %rt66.t2, align 4
Instruction does not dominate all uses!
  %r23.extracted.t1 = extractelement <4 x i32> %r23.vec, i32 1
  store i32 %r23.extracted.t1, i32* %rt66.t1, align 4
Broken module found, verification continues.
sequence() - A_gpu = 0x0cab600
verification failed for translated function for sequence : ""
LLVMDynamicTranslationCache.cpp:1244:

define internal void @_subkernel_sequence_1_opt1_ws4(%LLVMContext* %__ctaContext) nounwind align 1 {
SchedulerEntry:
  %0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %threadId.x.t0 = load i32* %0
  %1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %threadId.y.t0 = load i32* %1
  %2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 2
  %threadId.z.t0 = load i32* %2
  %3 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %blockDim.x.t0 = load i32* %3
  %4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %blockDim.y.t0 = load i32* %4
  %5 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 2
  %blockDim.z.t0 = load i32* %5
  %6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %blockId.x.t0 = load i32* %6
  %7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %blockId.y.t0 = load i32* %7
  %8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 2
  %blockId.z.t0 = load i32* %8
  %9 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 0
  %gridDim.x.t0 = load i32* %9
  %10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 1
  %gridDim.y.t0 = load i32* %10
  %11 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 2
  %gridDim.z.t0 = load i32* %11
  %localPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %localPtr.t0 = load i8** %localPtrPtr.t0
  %sharedPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5
  %sharedPtr.t0 = load i8** %sharedPtrPtr.t0
  %constPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 6
  %constPtr.t0 = load i8** %constPtrPtr.t0
  %paramPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 7
  %paramPtr.t0 = load i8** %paramPtrPtr.t0
  %argumentPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %argumentPtr.t0 = load i8** %argumentPtrPtr.t0
  %metadataPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 9
  %metadataPtr.t0 = load i8** %metadataPtrPtr.t0
  %bitcast = bitcast i8* %localPtr.t0 to i32*
  %encodedResumePoint = load i32* %bitcast
  %resumePoint = and i32 %encodedResumePoint, 65535
  %12 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 0
  %threadId.x.t1 = load i32* %12
  %13 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 1
  %threadId.y.t1 = load i32* %13
  %14 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 2
  %threadId.z.t1 = load i32* %14
  %15 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 0
  %blockDim.x.t1 = load i32* %15
  %16 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 1
  %blockDim.y.t1 = load i32* %16
  %17 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 2
  %blockDim.z.t1 = load i32* %17
  %18 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 0
  %blockId.x.t1 = load i32* %18
  %19 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 1
  %blockId.y.t1 = load i32* %19
  %20 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 2
  %blockId.z.t1 = load i32* %20
  %21 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 0
  %gridDim.x.t1 = load i32* %21
  %22 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 1
  %gridDim.y.t1 = load i32* %22
  %23 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 2
  %gridDim.z.t1 = load i32* %23
  %localPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 4
  %localPtr.t1 = load i8** %localPtrPtr.t1
  %sharedPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 5
  %sharedPtr.t1 = load i8** %sharedPtrPtr.t1
  %constPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 6
  %constPtr.t1 = load i8** %constPtrPtr.t1
  %paramPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 7
  %paramPtr.t1 = load i8** %paramPtrPtr.t1
  %argumentPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 8
  %argumentPtr.t1 = load i8** %argumentPtrPtr.t1
  %metadataPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 9
  %metadataPtr.t1 = load i8** %metadataPtrPtr.t1
  %24 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 0
  %threadId.x.t2 = load i32* %24
  %25 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 1
  %threadId.y.t2 = load i32* %25
  %26 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 2
  %threadId.z.t2 = load i32* %26
  %27 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 0
  %blockDim.x.t2 = load i32* %27
  %28 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 1
  %blockDim.y.t2 = load i32* %28
  %29 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 2
  %blockDim.z.t2 = load i32* %29
  %30 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 0
  %blockId.x.t2 = load i32* %30
  %31 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 1
  %blockId.y.t2 = load i32* %31
  %32 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 2
  %blockId.z.t2 = load i32* %32
  %33 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 0
  %gridDim.x.t2 = load i32* %33
  %34 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 1
  %gridDim.y.t2 = load i32* %34
  %35 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 2
  %gridDim.z.t2 = load i32* %35
  %localPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 4
  %localPtr.t2 = load i8** %localPtrPtr.t2
  %sharedPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 5
  %sharedPtr.t2 = load i8** %sharedPtrPtr.t2
  %constPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 6
  %constPtr.t2 = load i8** %constPtrPtr.t2
  %paramPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 7
  %paramPtr.t2 = load i8** %paramPtrPtr.t2
  %argumentPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 8
  %argumentPtr.t2 = load i8** %argumentPtrPtr.t2
  %metadataPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 9
  %metadataPtr.t2 = load i8** %metadataPtrPtr.t2
  %36 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 0
  %threadId.x.t3 = load i32* %36
  %insert.threadId.x.t0.vec = insertelement <4 x i32> undef, i32 %threadId.x.t0, i32 0
  %insert.threadId.x.t1.vec = insertelement <4 x i32> %insert.threadId.x.t0.vec, i32 %threadId.x.t1, i32 1
  %insert.threadId.x.t2.vec = insertelement <4 x i32> %insert.threadId.x.t1.vec, i32 %threadId.x.t2, i32 2
  %insert.threadId.x.t3.vec = insertelement <4 x i32> %insert.threadId.x.t2.vec, i32 %threadId.x.t3, i32 3
  %37 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 1
  %threadId.y.t3 = load i32* %37
  %38 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 2
  %threadId.z.t3 = load i32* %38
  %39 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 0
  %blockDim.x.t3 = load i32* %39
  %insert.blockDim.x.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.x.t0, i32 0
  %insert.blockDim.x.t1.vec = insertelement <4 x i32> %insert.blockDim.x.t0.vec, i32 %blockDim.x.t1, i32 1
  %insert.blockDim.x.t2.vec = insertelement <4 x i32> %insert.blockDim.x.t1.vec, i32 %blockDim.x.t2, i32 2
  %insert.blockDim.x.t3.vec = insertelement <4 x i32> %insert.blockDim.x.t2.vec, i32 %blockDim.x.t3, i32 3
  %40 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 1
  %blockDim.y.t3 = load i32* %40
  %41 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 2
  %blockDim.z.t3 = load i32* %41
  %42 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 0
  %blockId.x.t3 = load i32* %42
  %insert.blockId.x.t0.vec = insertelement <4 x i32> undef, i32 %blockId.x.t0, i32 0
  %insert.blockId.x.t1.vec = insertelement <4 x i32> %insert.blockId.x.t0.vec, i32 %blockId.x.t1, i32 1
  %insert.blockId.x.t2.vec = insertelement <4 x i32> %insert.blockId.x.t1.vec, i32 %blockId.x.t2, i32 2
  %insert.blockId.x.t3.vec = insertelement <4 x i32> %insert.blockId.x.t2.vec, i32 %blockId.x.t3, i32 3
  %43 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 1
  %blockId.y.t3 = load i32* %43
  %44 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 2
  %blockId.z.t3 = load i32* %44
  %45 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 0
  %gridDim.x.t3 = load i32* %45
  %46 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 1
  %gridDim.y.t3 = load i32* %46
  %47 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 2
  %gridDim.z.t3 = load i32* %47
  %localPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 4
  %localPtr.t3 = load i8** %localPtrPtr.t3
  %sharedPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 5
  %sharedPtr.t3 = load i8** %sharedPtrPtr.t3
  %constPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 6
  %constPtr.t3 = load i8** %constPtrPtr.t3
  %paramPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 7
  %paramPtr.t3 = load i8** %paramPtrPtr.t3
  %argumentPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 8
  %argumentPtr.t3 = load i8** %argumentPtrPtr.t3
  %metadataPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 9
  %metadataPtr.t3 = load i8** %metadataPtrPtr.t3
  switch i32 %resumePoint, label %"$BB_1_0002" [
    i32 1, label %"$BB_1_0002_to_$BB_1_0004_divergentEntry"
    i32 2, label %"$BB_1_0002_to_$BB_1_0003_divergentEntry"
  ]

"$BB_1_0002":                                     ; preds = %SchedulerEntry
  %rt2 = bitcast i8* %argumentPtr.t0 to i64*
  %rt2.t3 = bitcast i8* %argumentPtr.t3 to i64*
  %rt2.t2 = bitcast i8* %argumentPtr.t2 to i64*
  %rt2.t1 = bitcast i8* %argumentPtr.t1 to i64*
  %r0 = load i64* %rt2, align 8
  %r0.t3 = load i64* %rt2.t3, align 8
  %r0.t2 = load i64* %rt2.t2, align 8
  %r0.t1 = load i64* %rt2.t1, align 8
  %rt3 = getelementptr i8* %argumentPtr.t0, i32 8
  %rt3.t3 = getelementptr i8* %argumentPtr.t3, i32 8
  %rt3.t2 = getelementptr i8* %argumentPtr.t2, i32 8
  %rt3.t1 = getelementptr i8* %argumentPtr.t1, i32 8
  %rt6 = bitcast i8* %rt3 to i32*
  %rt6.t3 = bitcast i8* %rt3.t3 to i32*
  %rt6.t2 = bitcast i8* %rt3.t2 to i32*
  %rt6.t1 = bitcast i8* %rt3.t1 to i32*
  %r1 = load i32* %rt6, align 4
  %r1.t3 = load i32* %rt6.t3, align 4
  %r1.t2 = load i32* %rt6.t2, align 4
  %r1.t1 = load i32* %rt6.t1, align 4
  %rt13.vec = mul <4 x i32> %insert.blockDim.x.t3.vec, %insert.blockId.x.t3.vec
  %r6.vec = add <4 x i32> %insert.threadId.x.t3.vec, %rt13.vec
  %r6.extracted.t3 = extractelement <4 x i32> %r6.vec, i32 3
  %r6.extracted.t2 = extractelement <4 x i32> %r6.vec, i32 2
  %r6.extracted.t1 = extractelement <4 x i32> %r6.vec, i32 1
  %r6.extracted.t0 = extractelement <4 x i32> %r6.vec, i32 0
  %r7 = icmp slt i32 %r6.extracted.t0, %r1
  %r7.t3 = icmp slt i32 %r6.extracted.t3, %r1.t3
  %r7.t2 = icmp slt i32 %r6.extracted.t2, %r1.t2
  %r7.t1 = icmp slt i32 %r6.extracted.t1, %r1.t1
  %cond = zext i1 %r7 to i32
  %cond1 = zext i1 %r7.t1 to i32
  %cmpws = add i32 %cond, %cond1
  %cond2 = zext i1 %r7.t2 to i32
  %cmpws3 = add i32 %cmpws, %cond2
  %cond4 = zext i1 %r7.t3 to i32
  %cmpws5 = add i32 %cmpws3, %cond4
  switch i32 %cmpws5, label %"$BB_1_0002_to_$BB_1_0004_divergentYield" [
    i32 0, label %"$BB_1_0003"
    i32 4, label %"$BB_1_0004"
  ]

"$BB_1_0003":                                     ; preds = %"$BB_1_0002", %"$BB_1_0002_to_$BB_1_0003_divergentEntry"
  br label %exit

"$BB_1_0002_to_$BB_1_0004_divergentYield":        ; preds = %"$BB_1_0002"
  %r8 = phi i64 [ %r0, %"$BB_1_0002" ]
  %r8.t3 = phi i64 [ %r0.t3, %"$BB_1_0002" ]
  %r8.t2 = phi i64 [ %r0.t2, %"$BB_1_0002" ]
  %r8.t1 = phi i64 [ %r0.t1, %"$BB_1_0002" ]
  %r9 = phi i32 [ %r6.extracted.t0, %"$BB_1_0002" ]
  %r9.t3 = phi i32 [ %r6.extracted.t3, %"$BB_1_0002" ]
  %r9.t2 = phi i32 [ %r6.extracted.t2, %"$BB_1_0002" ]
  %r9.t1 = phi i32 [ %r6.extracted.t1, %"$BB_1_0002" ]
  %r10 = phi i1 [ %r7, %"$BB_1_0002" ]
  %r10.t3 = phi i1 [ %r7.t3, %"$BB_1_0002" ]
  %r10.t2 = phi i1 [ %r7.t2, %"$BB_1_0002" ]
  %r10.t1 = phi i1 [ %r7.t1, %"$BB_1_0002" ]
  %r11 = select i1 %r7, i32 65537, i32 65538
  %r11.t3 = select i1 %r7.t3, i32 65537, i32 65538
  %r11.t2 = select i1 %r7.t2, i32 65537, i32 65538
  %r11.t1 = select i1 %r7.t1, i32 65537, i32 65538
  %rt14 = zext i32 8 to i64
  %rt14.t3 = zext i32 8 to i64
  %rt14.t2 = zext i32 8 to i64
  %rt14.t1 = zext i32 8 to i64
  %rt17 = ptrtoint i8* %localPtr.t0 to i64
  %rt17.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt17.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt17.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt18 = add i64 %rt14, %rt17
  %rt18.t3 = add i64 %rt14.t3, %rt17.t3
  %rt18.t2 = add i64 %rt14.t2, %rt17.t2
  %rt18.t1 = add i64 %rt14.t1, %rt17.t1
  %rt19 = inttoptr i64 %rt18 to i64*
  %rt19.t3 = inttoptr i64 %rt18.t3 to i64*
  %rt19.t2 = inttoptr i64 %rt18.t2 to i64*
  %rt19.t1 = inttoptr i64 %rt18.t1 to i64*
  store i64 %r8, i64* %rt19, align 8
  store i64 %r8.t3, i64* %rt19.t3, align 8
  store i64 %r8.t2, i64* %rt19.t2, align 8
  store i64 %r8.t1, i64* %rt19.t1, align 8
  %rt20 = zext i32 8 to i64
  %rt20.t3 = zext i32 8 to i64
  %rt20.t2 = zext i32 8 to i64
  %rt20.t1 = zext i32 8 to i64
  %rt21 = add i64 %rt20, 8
  %rt21.t3 = add i64 %rt20.t3, 8
  %rt21.t2 = add i64 %rt20.t2, 8
  %rt21.t1 = add i64 %rt20.t1, 8
  %rt24 = ptrtoint i8* %localPtr.t0 to i64
  %rt24.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt24.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt24.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt25 = add i64 %rt21, %rt24
  %rt25.t3 = add i64 %rt21.t3, %rt24.t3
  %rt25.t2 = add i64 %rt21.t2, %rt24.t2
  %rt25.t1 = add i64 %rt21.t1, %rt24.t1
  %rt26 = inttoptr i64 %rt25 to i32*
  %rt26.t3 = inttoptr i64 %rt25.t3 to i32*
  %rt26.t2 = inttoptr i64 %rt25.t2 to i32*
  %rt26.t1 = inttoptr i64 %rt25.t1 to i32*
  store i32 %r9, i32* %rt26, align 4
  store i32 %r9.t3, i32* %rt26.t3, align 4
  store i32 %r9.t2, i32* %rt26.t2, align 4
  store i32 %r9.t1, i32* %rt26.t1, align 4
  %rt27 = zext i32 4 to i64
  %rt27.t3 = zext i32 4 to i64
  %rt27.t2 = zext i32 4 to i64
  %rt27.t1 = zext i32 4 to i64
  %rt30 = ptrtoint i8* %localPtr.t0 to i64
  %rt30.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt30.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt30.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt31 = add i64 %rt27, %rt30
  %rt31.t3 = add i64 %rt27.t3, %rt30.t3
  %rt31.t2 = add i64 %rt27.t2, %rt30.t2
  %rt31.t1 = add i64 %rt27.t1, %rt30.t1
  %rt32 = inttoptr i64 %rt31 to i32*
  %rt32.t3 = inttoptr i64 %rt31.t3 to i32*
  %rt32.t2 = inttoptr i64 %rt31.t2 to i32*
  %rt32.t1 = inttoptr i64 %rt31.t1 to i32*
  store i32 2, i32* %rt32, align 4
  store i32 2, i32* %rt32.t3, align 4
  store i32 2, i32* %rt32.t2, align 4
  store i32 2, i32* %rt32.t1, align 4
  %rt33 = zext i32 0 to i64
  %rt33.t3 = zext i32 0 to i64
  %rt33.t2 = zext i32 0 to i64
  %rt33.t1 = zext i32 0 to i64
  %rt36 = ptrtoint i8* %localPtr.t0 to i64
  %rt36.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt36.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt36.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt37 = add i64 %rt33, %rt36
  %rt37.t3 = add i64 %rt33.t3, %rt36.t3
  %rt37.t2 = add i64 %rt33.t2, %rt36.t2
  %rt37.t1 = add i64 %rt33.t1, %rt36.t1
  %rt38 = inttoptr i64 %rt37 to i32*
  %rt38.t3 = inttoptr i64 %rt37.t3 to i32*
  %rt38.t2 = inttoptr i64 %rt37.t2 to i32*
  %rt38.t1 = inttoptr i64 %rt37.t1 to i32*
  store i32 %r11, i32* %rt38, align 4
  store i32 %r11.t3, i32* %rt38.t3, align 4
  store i32 %r11.t2, i32* %rt38.t2, align 4
  store i32 %r11.t1, i32* %rt38.t1, align 4
  br label %exit

"$BB_1_0002_to_$BB_1_0003_divergentEntry":        ; preds = %SchedulerEntry
  %rt39 = zext i32 8 to i64
  %rt39.t3 = zext i32 8 to i64
  %rt39.t2 = zext i32 8 to i64
  %rt39.t1 = zext i32 8 to i64
  %rt42 = ptrtoint i8* %localPtr.t0 to i64
  %rt42.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt42.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt42.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt43 = add i64 %rt39, %rt42
  %rt43.t3 = add i64 %rt39.t3, %rt42.t3
  %rt43.t2 = add i64 %rt39.t2, %rt42.t2
  %rt43.t1 = add i64 %rt39.t1, %rt42.t1
  %rt44 = inttoptr i64 %rt43 to i64*
  %rt44.t3 = inttoptr i64 %rt43.t3 to i64*
  %rt44.t2 = inttoptr i64 %rt43.t2 to i64*
  %rt44.t1 = inttoptr i64 %rt43.t1 to i64*
  %r16 = load i64* %rt44, align 8
  %r16.t3 = load i64* %rt44.t3, align 8
  %r16.t2 = load i64* %rt44.t2, align 8
  %r16.t1 = load i64* %rt44.t1, align 8
  %rt45 = zext i32 8 to i64
  %rt45.t3 = zext i32 8 to i64
  %rt45.t2 = zext i32 8 to i64
  %rt45.t1 = zext i32 8 to i64
  %rt46 = add i64 %rt45, 8
  %rt46.t3 = add i64 %rt45.t3, 8
  %rt46.t2 = add i64 %rt45.t2, 8
  %rt46.t1 = add i64 %rt45.t1, 8
  %rt49 = ptrtoint i8* %localPtr.t0 to i64
  %rt49.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt49.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt49.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt50 = add i64 %rt46, %rt49
  %rt50.t3 = add i64 %rt46.t3, %rt49.t3
  %rt50.t2 = add i64 %rt46.t2, %rt49.t2
  %rt50.t1 = add i64 %rt46.t1, %rt49.t1
  %rt51 = inttoptr i64 %rt50 to i32*
  %rt51.t3 = inttoptr i64 %rt50.t3 to i32*
  %rt51.t2 = inttoptr i64 %rt50.t2 to i32*
  %rt51.t1 = inttoptr i64 %rt50.t1 to i32*
  %r17 = load i32* %rt51, align 4
  %r17.t3 = load i32* %rt51.t3, align 4
  %r17.t2 = load i32* %rt51.t2, align 4
  %r17.t1 = load i32* %rt51.t1, align 4
  br label %"$BB_1_0003"

"$BB_1_0002_to_$BB_1_0004_divergentEntry":        ; preds = %SchedulerEntry
  %rt52 = zext i32 8 to i64
  %rt52.t3 = zext i32 8 to i64
  %rt52.t2 = zext i32 8 to i64
  %rt52.t1 = zext i32 8 to i64
  %rt55 = ptrtoint i8* %localPtr.t0 to i64
  %rt55.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt55.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt55.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt56 = add i64 %rt52, %rt55
  %rt56.t3 = add i64 %rt52.t3, %rt55.t3
  %rt56.t2 = add i64 %rt52.t2, %rt55.t2
  %rt56.t1 = add i64 %rt52.t1, %rt55.t1
  %rt57 = inttoptr i64 %rt56 to i64*
  %rt57.t3 = inttoptr i64 %rt56.t3 to i64*
  %rt57.t2 = inttoptr i64 %rt56.t2 to i64*
  %rt57.t1 = inttoptr i64 %rt56.t1 to i64*
  %r19 = load i64* %rt57, align 8
  %r19.t3 = load i64* %rt57.t3, align 8
  %r19.t2 = load i64* %rt57.t2, align 8
  %r19.t1 = load i64* %rt57.t1, align 8
  %rt58 = zext i32 8 to i64
  %rt58.t3 = zext i32 8 to i64
  %rt58.t2 = zext i32 8 to i64
  %rt58.t1 = zext i32 8 to i64
  %rt59 = add i64 %rt58, 8
  %rt59.t3 = add i64 %rt58.t3, 8
  %rt59.t2 = add i64 %rt58.t2, 8
  %rt59.t1 = add i64 %rt58.t1, 8
  %rt62 = ptrtoint i8* %localPtr.t0 to i64
  %rt62.t3 = ptrtoint i8* %localPtr.t3 to i64
  %rt62.t2 = ptrtoint i8* %localPtr.t2 to i64
  %rt62.t1 = ptrtoint i8* %localPtr.t1 to i64
  %rt63 = add i64 %rt59, %rt62
  %rt63.t3 = add i64 %rt59.t3, %rt62.t3
  %rt63.t2 = add i64 %rt59.t2, %rt62.t2
  %rt63.t1 = add i64 %rt59.t1, %rt62.t1
  %rt64 = inttoptr i64 %rt63 to i32*
  %rt64.t3 = inttoptr i64 %rt63.t3 to i32*
  %rt64.t2 = inttoptr i64 %rt63.t2 to i32*
  %rt64.t1 = inttoptr i64 %rt63.t1 to i32*
  %r20 = load i32* %rt64, align 4
  %r20.t3 = load i32* %rt64.t3, align 4
  %r20.t2 = load i32* %rt64.t2, align 4
  %r20.t1 = load i32* %rt64.t1, align 4
  br label %"$BB_1_0004"

"$BB_1_0004":                                     ; preds = %"$BB_1_0002", %"$BB_1_0002_to_$BB_1_0004_divergentEntry"
  %r22 = phi i32 [ %r20, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t0, %"$BB_1_0002" ]
  %r22.t3 = phi i32 [ %r20.t3, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t3, %"$BB_1_0002" ]
  %insert.r22.vec = insertelement <4 x i32> undef, i32 %r22, i32 0
  %insert.r22.t1.vec = insertelement <4 x i32> %insert.r22.vec, i32 %r22.t1, i32 1
  %insert.r22.t2.vec = insertelement <4 x i32> %insert.r22.t1.vec, i32 %r22.t2, i32 2
  %insert.r22.t3.vec = insertelement <4 x i32> %insert.r22.t2.vec, i32 %r22.t3, i32 3
  %r22.t2 = phi i32 [ %r20.t2, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t2, %"$BB_1_0002" ]
  %r22.t1 = phi i32 [ %r20.t1, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r6.extracted.t1, %"$BB_1_0002" ]
  %r21 = phi i64 [ %r19, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r0, %"$BB_1_0002" ]
  %r21.t3 = phi i64 [ %r19.t3, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r0.t3, %"$BB_1_0002" ]
  %r21.t2 = phi i64 [ %r19.t2, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r0.t2, %"$BB_1_0002" ]
  %r21.t1 = phi i64 [ %r19.t1, %"$BB_1_0002_to_$BB_1_0004_divergentEntry" ], [ %r0.t1, %"$BB_1_0002" ]
  %48 = insertelement <4 x i32> undef, i32 1, i32 0
  %49 = insertelement <4 x i32> %48, i32 1, i32 1
  %50 = insertelement <4 x i32> %49, i32 1, i32 2
  %51 = insertelement <4 x i32> %50, i32 1, i32 3
  %r23.vec = shl <4 x i32> %insert.r22.t3.vec, %51
  %r23.extracted.t3 = extractelement <4 x i32> %r23.vec, i32 3
  %r23.extracted.t2 = extractelement <4 x i32> %r23.vec, i32 2
  %r23.extracted.t1 = extractelement <4 x i32> %r23.vec, i32 1
  %r23.extracted.t0 = extractelement <4 x i32> %r23.vec, i32 0
  %rt65 = sext i32 %r22 to i64
  %rt65.t3 = sext i32 %r22.t3 to i64
  %rt65.t2 = sext i32 %r22.t2 to i64
  %rt65.t1 = sext i32 %r22.t1 to i64
  %r24 = mul i64 %rt65, 4
  %r24.t3 = mul i64 %rt65.t3, 4
  %r24.t2 = mul i64 %rt65.t2, 4
  %r24.t1 = mul i64 %rt65.t1, 4
  %r25 = add i64 %r21, %r24
  %r25.t3 = add i64 %r21.t3, %r24.t3
  %r25.t2 = add i64 %r21.t2, %r24.t2
  %r25.t1 = add i64 %r21.t1, %r24.t1
  %rt66 = inttoptr i64 %r25 to i32*
  %rt66.t3 = inttoptr i64 %r25.t3 to i32*
  %rt66.t2 = inttoptr i64 %r25.t2 to i32*
  %rt66.t1 = inttoptr i64 %r25.t1 to i32*
  store i32 %r23.extracted.t0, i32* %rt66, align 4
  store i32 %r23.extracted.t3, i32* %rt66.t3, align 4
  store i32 %r23.extracted.t2, i32* %rt66.t2, align 4
  store i32 %r23.extracted.t1, i32* %rt66.t1, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0004", %"$BB_1_0002_to_$BB_1_0004_divergentYield", %"$BB_1_0003"
  ret void
}


error on subkernel: _Z_ocelotTranslated__subkernel_sequence_1
 specialization: _subkernel_sequence_1_opt1_ws4
TestCudaSequence: ocelot/executive/implementation/DynamicTranslationCache.cpp:1253: void cloneAndOptimizeTranslation(executive::DynamicTranslationCache::TranslatedKernel&, executive::DynamicTranslationCache::TranslatedSubkernel&, executive::DynamicTranslationCache::SubkernelId, executive::DynamicTranslationCache::Translation*, int, translator::Translator::OptimizationLevel, unsigned int, bool): Assertion `0 && "due to broken LLVM translation"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestKernels 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestIndirectFunctionCall
INFO     Test completed in 0.0432388782501 seconds
INFO      It produced the following output:
TestIndirectFunctionCall: ocelot/executive/implementation/DynamicTranslationCache.cpp:1027: void setupCallTargets(ir::PTXKernel&, const executive::DynamicTranslationCache&): Assertion `0 && "arbitrary function calls not yet supported"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCalVectorScale 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLexer
INFO     Test completed in 0.0579969882965 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLexer

Description: Tests for the PTX lexer. Test Point 1: Scan a PTX file and 
             write out a temp stream, scan the stream again and make sure that the 
             two sets of tokens match


Test Seed : 1335814028
Test time : 1.62125e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMKernels 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTextureArray
INFO     Test completed in 0.0687880516052 seconds
INFO      It produced the following output:
Instruction does not dominate all uses!
  %r1.t1 = load i32* %rt6.t1, align 4
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
Instruction does not dominate all uses!
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
Instruction does not dominate all uses!
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
Instruction does not dominate all uses!
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
Instruction does not dominate all uses!
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
Instruction does not dominate all uses!
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
Instruction does not dominate all uses!
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
  %rt25 = zext i32 %r18.extracted.t0 to i64
Instruction does not dominate all uses!
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
Instruction does not dominate all uses!
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
Instruction does not dominate all uses!
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
Instruction does not dominate all uses!
  %rt25 = zext i32 %r18.extracted.t0 to i64
  %r19 = mul i64 %rt25, 4
Instruction does not dominate all uses!
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
  %r19.t3 = mul i64 %rt25.t3, 4
Instruction does not dominate all uses!
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
  %r19.t2 = mul i64 %rt25.t2, 4
Instruction does not dominate all uses!
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
  %r19.t1 = mul i64 %rt25.t1, 4
Instruction does not dominate all uses!
  %r19 = mul i64 %rt25, 4
  %r20 = add i64 %r0, %r19
Instruction does not dominate all uses!
  %r19.t3 = mul i64 %rt25.t3, 4
  %r20.t3 = add i64 %r0.t3, %r19.t3
Instruction does not dominate all uses!
  %r19.t2 = mul i64 %rt25.t2, 4
  %r20.t2 = add i64 %r0.t2, %r19.t2
Instruction does not dominate all uses!
  %r19.t1 = mul i64 %rt25.t1, 4
  %r20.t1 = add i64 %r0.t1, %r19.t1
Instruction does not dominate all uses!
  %r20 = add i64 %r0, %r19
  %rt26 = inttoptr i64 %r20 to float*
Instruction does not dominate all uses!
  %r20.t3 = add i64 %r0.t3, %r19.t3
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
Instruction does not dominate all uses!
  %r20.t2 = add i64 %r0.t2, %r19.t2
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
Instruction does not dominate all uses!
  %r20.t1 = add i64 %r0.t1, %r19.t1
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
Instruction does not dominate all uses!
  %rt26 = inttoptr i64 %r20 to float*
  store float %r14, float* %rt26, align 4
Instruction does not dominate all uses!
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
  store float %r14.t3, float* %rt26.t3, align 4
Instruction does not dominate all uses!
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
  store float %r14.t2, float* %rt26.t2, align 4
Instruction does not dominate all uses!
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
  store float %r14.t1, float* %rt26.t1, align 4
Broken module found, verification continues.
verification failed for translated function for _Z6kernelPfii : ""
LLVMDynamicTranslationCache.cpp:1244:

define internal void @_subkernel__Z6kernelPfii_1_opt1_ws4(%LLVMContext* %__ctaContext) nounwind align 1 {
SchedulerEntry:
  %0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %threadId.x.t0 = load i32* %0
  %1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %threadId.y.t0 = load i32* %1
  %2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 2
  %threadId.z.t0 = load i32* %2
  %3 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %blockDim.x.t0 = load i32* %3
  %4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %blockDim.y.t0 = load i32* %4
  %5 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 2
  %blockDim.z.t0 = load i32* %5
  %6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %blockId.x.t0 = load i32* %6
  %7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %blockId.y.t0 = load i32* %7
  %8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 2
  %blockId.z.t0 = load i32* %8
  %9 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 0
  %gridDim.x.t0 = load i32* %9
  %10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 1
  %gridDim.y.t0 = load i32* %10
  %11 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 2
  %gridDim.z.t0 = load i32* %11
  %localPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %localPtr.t0 = load i8** %localPtrPtr.t0
  %sharedPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5
  %sharedPtr.t0 = load i8** %sharedPtrPtr.t0
  %constPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 6
  %constPtr.t0 = load i8** %constPtrPtr.t0
  %paramPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 7
  %paramPtr.t0 = load i8** %paramPtrPtr.t0
  %argumentPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %argumentPtr.t0 = load i8** %argumentPtrPtr.t0
  %metadataPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 9
  %metadataPtr.t0 = load i8** %metadataPtrPtr.t0
  %integerTexture = alloca i32, i32 4, align 16
  %floatingPointTexture = alloca float, i32 4, align 16
  %bitcast = bitcast i8* %localPtr.t0 to i32*
  %encodedResumePoint = load i32* %bitcast
  %resumePoint = and i32 %encodedResumePoint, 65535
  %12 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 0
  %threadId.x.t1 = load i32* %12
  %13 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 1
  %threadId.y.t1 = load i32* %13
  %14 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 2
  %threadId.z.t1 = load i32* %14
  %15 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 0
  %blockDim.x.t1 = load i32* %15
  %16 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 1
  %blockDim.y.t1 = load i32* %16
  %17 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 2
  %blockDim.z.t1 = load i32* %17
  %18 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 0
  %blockId.x.t1 = load i32* %18
  %19 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 1
  %blockId.y.t1 = load i32* %19
  %20 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 2
  %blockId.z.t1 = load i32* %20
  %21 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 0
  %gridDim.x.t1 = load i32* %21
  %22 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 1
  %gridDim.y.t1 = load i32* %22
  %23 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 2
  %gridDim.z.t1 = load i32* %23
  %localPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 4
  %localPtr.t1 = load i8** %localPtrPtr.t1
  %sharedPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 5
  %sharedPtr.t1 = load i8** %sharedPtrPtr.t1
  %constPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 6
  %constPtr.t1 = load i8** %constPtrPtr.t1
  %paramPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 7
  %paramPtr.t1 = load i8** %paramPtrPtr.t1
  %argumentPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 8
  %argumentPtr.t1 = load i8** %argumentPtrPtr.t1
  %metadataPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 9
  %metadataPtr.t1 = load i8** %metadataPtrPtr.t1
  %24 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 0
  %threadId.x.t2 = load i32* %24
  %25 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 1
  %threadId.y.t2 = load i32* %25
  %26 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 2
  %threadId.z.t2 = load i32* %26
  %27 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 0
  %blockDim.x.t2 = load i32* %27
  %28 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 1
  %blockDim.y.t2 = load i32* %28
  %29 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 2
  %blockDim.z.t2 = load i32* %29
  %30 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 0
  %blockId.x.t2 = load i32* %30
  %31 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 1
  %blockId.y.t2 = load i32* %31
  %32 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 2
  %blockId.z.t2 = load i32* %32
  %33 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 0
  %gridDim.x.t2 = load i32* %33
  %34 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 1
  %gridDim.y.t2 = load i32* %34
  %35 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 2
  %gridDim.z.t2 = load i32* %35
  %localPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 4
  %localPtr.t2 = load i8** %localPtrPtr.t2
  %sharedPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 5
  %sharedPtr.t2 = load i8** %sharedPtrPtr.t2
  %constPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 6
  %constPtr.t2 = load i8** %constPtrPtr.t2
  %paramPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 7
  %paramPtr.t2 = load i8** %paramPtrPtr.t2
  %argumentPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 8
  %argumentPtr.t2 = load i8** %argumentPtrPtr.t2
  %metadataPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 9
  %metadataPtr.t2 = load i8** %metadataPtrPtr.t2
  %36 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 0
  %threadId.x.t3 = load i32* %36
  %insert.threadId.x.t0.vec = insertelement <4 x i32> undef, i32 %threadId.x.t0, i32 0
  %insert.threadId.x.t1.vec = insertelement <4 x i32> %insert.threadId.x.t0.vec, i32 %threadId.x.t1, i32 1
  %insert.threadId.x.t2.vec = insertelement <4 x i32> %insert.threadId.x.t1.vec, i32 %threadId.x.t2, i32 2
  %insert.threadId.x.t3.vec = insertelement <4 x i32> %insert.threadId.x.t2.vec, i32 %threadId.x.t3, i32 3
  %37 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 1
  %threadId.y.t3 = load i32* %37
  %insert.threadId.y.t0.vec = insertelement <4 x i32> undef, i32 %threadId.y.t0, i32 0
  %insert.threadId.y.t1.vec = insertelement <4 x i32> %insert.threadId.y.t0.vec, i32 %threadId.y.t1, i32 1
  %insert.threadId.y.t2.vec = insertelement <4 x i32> %insert.threadId.y.t1.vec, i32 %threadId.y.t2, i32 2
  %insert.threadId.y.t3.vec = insertelement <4 x i32> %insert.threadId.y.t2.vec, i32 %threadId.y.t3, i32 3
  %38 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 2
  %threadId.z.t3 = load i32* %38
  %39 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 0
  %blockDim.x.t3 = load i32* %39
  %insert.blockDim.x.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.x.t0, i32 0
  %insert.blockDim.x.t1.vec = insertelement <4 x i32> %insert.blockDim.x.t0.vec, i32 %blockDim.x.t1, i32 1
  %insert.blockDim.x.t2.vec = insertelement <4 x i32> %insert.blockDim.x.t1.vec, i32 %blockDim.x.t2, i32 2
  %insert.blockDim.x.t3.vec = insertelement <4 x i32> %insert.blockDim.x.t2.vec, i32 %blockDim.x.t3, i32 3
  %40 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 1
  %blockDim.y.t3 = load i32* %40
  %insert.blockDim.y.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.y.t0, i32 0
  %insert.blockDim.y.t1.vec = insertelement <4 x i32> %insert.blockDim.y.t0.vec, i32 %blockDim.y.t1, i32 1
  %insert.blockDim.y.t2.vec = insertelement <4 x i32> %insert.blockDim.y.t1.vec, i32 %blockDim.y.t2, i32 2
  %insert.blockDim.y.t3.vec = insertelement <4 x i32> %insert.blockDim.y.t2.vec, i32 %blockDim.y.t3, i32 3
  %41 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 2
  %blockDim.z.t3 = load i32* %41
  %42 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 0
  %blockId.x.t3 = load i32* %42
  %insert.blockId.x.t0.vec = insertelement <4 x i32> undef, i32 %blockId.x.t0, i32 0
  %insert.blockId.x.t1.vec = insertelement <4 x i32> %insert.blockId.x.t0.vec, i32 %blockId.x.t1, i32 1
  %insert.blockId.x.t2.vec = insertelement <4 x i32> %insert.blockId.x.t1.vec, i32 %blockId.x.t2, i32 2
  %insert.blockId.x.t3.vec = insertelement <4 x i32> %insert.blockId.x.t2.vec, i32 %blockId.x.t3, i32 3
  %43 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 1
  %blockId.y.t3 = load i32* %43
  %insert.blockId.y.t0.vec = insertelement <4 x i32> undef, i32 %blockId.y.t0, i32 0
  %insert.blockId.y.t1.vec = insertelement <4 x i32> %insert.blockId.y.t0.vec, i32 %blockId.y.t1, i32 1
  %insert.blockId.y.t2.vec = insertelement <4 x i32> %insert.blockId.y.t1.vec, i32 %blockId.y.t2, i32 2
  %insert.blockId.y.t3.vec = insertelement <4 x i32> %insert.blockId.y.t2.vec, i32 %blockId.y.t3, i32 3
  %44 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 2
  %blockId.z.t3 = load i32* %44
  %45 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 0
  %gridDim.x.t3 = load i32* %45
  %46 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 1
  %gridDim.y.t3 = load i32* %46
  %47 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 2
  %gridDim.z.t3 = load i32* %47
  %localPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 4
  %localPtr.t3 = load i8** %localPtrPtr.t3
  %sharedPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 5
  %sharedPtr.t3 = load i8** %sharedPtrPtr.t3
  %constPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 6
  %constPtr.t3 = load i8** %constPtrPtr.t3
  %paramPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 7
  %paramPtr.t3 = load i8** %paramPtrPtr.t3
  %argumentPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 8
  %argumentPtr.t3 = load i8** %argumentPtrPtr.t3
  %metadataPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 9
  %metadataPtr.t3 = load i8** %metadataPtrPtr.t3
  switch i32 %resumePoint, label %"$BB_1_0002" [
  ]

"$BB_1_0002":                                     ; preds = %SchedulerEntry
  %rt2 = bitcast i8* %argumentPtr.t0 to i64*
  %rt2.t3 = bitcast i8* %argumentPtr.t3 to i64*
  %rt2.t2 = bitcast i8* %argumentPtr.t2 to i64*
  %rt2.t1 = bitcast i8* %argumentPtr.t1 to i64*
  %r0 = load i64* %rt2, align 8
  %r0.t3 = load i64* %rt2.t3, align 8
  %r0.t2 = load i64* %rt2.t2, align 8
  %r0.t1 = load i64* %rt2.t1, align 8
  %rt3 = getelementptr i8* %argumentPtr.t0, i32 8
  %rt3.t3 = getelementptr i8* %argumentPtr.t3, i32 8
  %rt3.t2 = getelementptr i8* %argumentPtr.t2, i32 8
  %rt3.t1 = getelementptr i8* %argumentPtr.t1, i32 8
  %rt6 = bitcast i8* %rt3 to i32*
  %rt6.t3 = bitcast i8* %rt3.t3 to i32*
  %rt6.t2 = bitcast i8* %rt3.t2 to i32*
  %rt6.t1 = bitcast i8* %rt3.t1 to i32*
  %r1 = load i32* %rt6, align 4
  %r1.t3 = load i32* %rt6.t3, align 4
  %insert.r1.vec = insertelement <4 x i32> undef, i32 %r1, i32 0
  %insert.r1.t1.vec = insertelement <4 x i32> %insert.r1.vec, i32 %r1.t1, i32 1
  %insert.r1.t2.vec = insertelement <4 x i32> %insert.r1.t1.vec, i32 %r1.t2, i32 2
  %insert.r1.t3.vec = insertelement <4 x i32> %insert.r1.t2.vec, i32 %r1.t3, i32 3
  %r1.t2 = load i32* %rt6.t2, align 4
  %r1.t1 = load i32* %rt6.t1, align 4
  %rt13.vec = mul <4 x i32> %insert.blockDim.x.t3.vec, %insert.blockId.x.t3.vec
  %r6.vec = add <4 x i32> %insert.threadId.x.t3.vec, %rt13.vec
  %r6.extracted.t3 = extractelement <4 x i32> %r6.vec, i32 3
  %r6.extracted.t2 = extractelement <4 x i32> %r6.vec, i32 2
  %r6.extracted.t1 = extractelement <4 x i32> %r6.vec, i32 1
  %r6.extracted.t0 = extractelement <4 x i32> %r6.vec, i32 0
  %rt20.vec = mul <4 x i32> %insert.blockDim.y.t3.vec, %insert.blockId.y.t3.vec
  %r10.vec = add <4 x i32> %insert.threadId.y.t3.vec, %rt20.vec
  %r10.extracted.t3 = extractelement <4 x i32> %r10.vec, i32 3
  %r10.extracted.t2 = extractelement <4 x i32> %r10.vec, i32 2
  %r10.extracted.t1 = extractelement <4 x i32> %r10.vec, i32 1
  %r10.extracted.t0 = extractelement <4 x i32> %r10.vec, i32 0
  %r11 = uitofp i32 %r6.extracted.t0 to float
  %r11.t3 = uitofp i32 %r6.extracted.t3 to float
  %r11.t2 = uitofp i32 %r6.extracted.t2 to float
  %r11.t1 = uitofp i32 %r6.extracted.t1 to float
  %r12 = uitofp i32 %r10.extracted.t0 to float
  %r12.t3 = uitofp i32 %r10.extracted.t3 to float
  %r12.t2 = uitofp i32 %r10.extracted.t2 to float
  %r12.t1 = uitofp i32 %r10.extracted.t1 to float
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11, float %r12)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t3, float %r12.t3)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t2, float %r12.t2)
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r11.t1, float %r12.t1)
  %r14 = load float* %floatingPointTexture
  %r14.t3 = load float* %floatingPointTexture
  %r14.t2 = load float* %floatingPointTexture
  %r14.t1 = load float* %floatingPointTexture
  %rt21 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t3 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t2 = getelementptr float* %floatingPointTexture, i32 1
  %rt21.t1 = getelementptr float* %floatingPointTexture, i32 1
  %r15 = load float* %rt21
  %r15.t3 = load float* %rt21.t3
  %r15.t2 = load float* %rt21.t2
  %r15.t1 = load float* %rt21.t1
  %rt22 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t3 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t2 = getelementptr float* %floatingPointTexture, i32 2
  %rt22.t1 = getelementptr float* %floatingPointTexture, i32 2
  %r16 = load float* %rt22
  %r16.t3 = load float* %rt22.t3
  %r16.t2 = load float* %rt22.t2
  %r16.t1 = load float* %rt22.t1
  %rt23 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t3 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t2 = getelementptr float* %floatingPointTexture, i32 3
  %rt23.t1 = getelementptr float* %floatingPointTexture, i32 3
  %r17 = load float* %rt23
  %r17.t3 = load float* %rt23.t3
  %r17.t2 = load float* %rt23.t2
  %r17.t1 = load float* %rt23.t1
  %rt24.vec = mul <4 x i32> %r10.vec, %insert.r1.t3.vec
  %r18.vec = add <4 x i32> %r6.vec, %rt24.vec
  %r18.extracted.t3 = extractelement <4 x i32> %r18.vec, i32 3
  %r18.extracted.t2 = extractelement <4 x i32> %r18.vec, i32 2
  %r18.extracted.t1 = extractelement <4 x i32> %r18.vec, i32 1
  %r18.extracted.t0 = extractelement <4 x i32> %r18.vec, i32 0
  %rt25 = zext i32 %r18.extracted.t0 to i64
  %rt25.t3 = zext i32 %r18.extracted.t3 to i64
  %rt25.t2 = zext i32 %r18.extracted.t2 to i64
  %rt25.t1 = zext i32 %r18.extracted.t1 to i64
  %r19 = mul i64 %rt25, 4
  %r19.t3 = mul i64 %rt25.t3, 4
  %r19.t2 = mul i64 %rt25.t2, 4
  %r19.t1 = mul i64 %rt25.t1, 4
  %r20 = add i64 %r0, %r19
  %r20.t3 = add i64 %r0.t3, %r19.t3
  %r20.t2 = add i64 %r0.t2, %r19.t2
  %r20.t1 = add i64 %r0.t1, %r19.t1
  %rt26 = inttoptr i64 %r20 to float*
  %rt26.t3 = inttoptr i64 %r20.t3 to float*
  %rt26.t2 = inttoptr i64 %r20.t2 to float*
  %rt26.t1 = inttoptr i64 %r20.t1 to float*
  store float %r14, float* %rt26, align 4
  store float %r14.t3, float* %rt26.t3, align 4
  store float %r14.t2, float* %rt26.t2, align 4
  store float %r14.t1, float* %rt26.t1, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002"
  ret void
}


error on subkernel: _Z_ocelotTranslated__subkernel__Z6kernelPfii_1
 specialization: _subkernel__Z6kernelPfii_1_opt1_ws4
TestCudaTextureArray: ocelot/executive/implementation/DynamicTranslationCache.cpp:1253: void cloneAndOptimizeTranslation(executive::DynamicTranslationCache::TranslatedKernel&, executive::DynamicTranslationCache::TranslatedSubkernel&, executive::DynamicTranslationCache::SubkernelId, executive::DynamicTranslationCache::Translation*, int, translator::Translator::OptimizationLevel, unsigned int, bool): Assertion `0 && "due to broken LLVM translation"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestParser -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestKernels
INFO     Test completed in 0.0629069805145 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestKernels

Description: 


Test Seed : 1335814028
Test time : 0.0125799

Status : Test output:
looping kernel succeeded
matrix vector kernel succeeded



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCalVectorScale
INFO     Test completed in 0.0445919036865 seconds
INFO      It produced the following output:
No CAL devices found
Pass/Fail : Pass

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestExternalFunctions 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaGlobals 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestExternalFunctions
INFO     Test completed in 0.0405540466309 seconds
INFO      It produced the following output:
TestExternalFunctions: ocelot/executive/implementation/DynamicTranslationCache.cpp:1027: void setupCallTargets(ir::PTXKernel&, const executive::DynamicTranslationCache&): Assertion `0 && "arbitrary function calls not yet supported"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestEmulator 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestParser
INFO     Test completed in 0.0592799186707 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestParser

Description: A test for the PTXParser class. Test Points: 1) Load a PTX file 
             and run it through the parser generating a module. Write the 
             module to an intermediate stream. Parse the stream again 
             generating a new module, compare both to make sure that they match.


Test Seed : 1335814028
Test time : 1.23978e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXAssembly 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMKernels
INFO     Test completed in 0.111145973206 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLLVMKernels

Description: A unit test for the LLVM executive runtime. Test Points: 1) 
             Execute a kernel with a loop. 2) Execute a matrix multiply kernel.


Test Seed : 1335814028
Test time : 0.0605173

Status : A = [
 1 0 0 0 0 0 0 0 ;
 0.5 1 0 0 0 0 0 0 ;
 0.333333 0.5 1 0 0 0 0 0 ;
 0.25 0.333333 0.5 1 0 0 0 0 ;
 0.2 0.25 0.333333 0.5 1 0 0 0 ;
 0.166667 0.2 0.25 0.333333 0.5 1 0 0 ;
 0.142857 0.166667 0.2 0.25 0.333333 0.5 1 0 ;
 0.125 0.142857 0.166667 0.2 0.25 0.333333 0.5 1 ;
];
V = [
 1 ;
 2 ;
 3 ;
 4 ;
 5 ;
 6 ;
 7 ;
 8 ;
];
R = [
 1 ;
 2.5 ;
 4.33333 ;
 6.41667 ;
 8.7 ;
 11.15 ;
 13.7429 ;
 16.4607 ;
];



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaMalloc 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaGlobals
INFO     Test completed in 0.0814249515533 seconds
INFO      It produced the following output:
Instruction does not dominate all uses!
  %r6.t1 = load float* @Pi, align 4
  %insert.r6.t1.vec = insertelement <4 x float> %insert.r6.vec, float %r6.t1, i32 1
Instruction does not dominate all uses!
  %insert.r6.t1.vec = insertelement <4 x float> %insert.r6.vec, float %r6.t1, i32 1
  %insert.r6.t2.vec = insertelement <4 x float> %insert.r6.t1.vec, float %r6.t2, i32 2
Instruction does not dominate all uses!
  %insert.r6.t2.vec = insertelement <4 x float> %insert.r6.t1.vec, float %r6.t2, i32 2
  %insert.r6.t3.vec = insertelement <4 x float> %insert.r6.t2.vec, float %r6.t3, i32 3
Instruction does not dominate all uses!
  %r12.t1 = sitofp i32 %r11.extracted.t1 to float
  %insert.r12.t1.vec = insertelement <4 x float> %insert.r12.vec, float %r12.t1, i32 1
Instruction does not dominate all uses!
  %insert.r12.t1.vec = insertelement <4 x float> %insert.r12.vec, float %r12.t1, i32 1
  %insert.r12.t2.vec = insertelement <4 x float> %insert.r12.t1.vec, float %r12.t2, i32 2
Instruction does not dominate all uses!
  %insert.r12.t2.vec = insertelement <4 x float> %insert.r12.t1.vec, float %r12.t2, i32 2
  %insert.r12.t3.vec = insertelement <4 x float> %insert.r12.t2.vec, float %r12.t3, i32 3
Instruction does not dominate all uses!
  %insert.r6.t3.vec = insertelement <4 x float> %insert.r6.t2.vec, float %r6.t3, i32 3
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
Instruction does not dominate all uses!
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
  %r13.extracted.t3 = extractelement <4 x float> %r13.vec, i32 3
Instruction does not dominate all uses!
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
  %r13.extracted.t2 = extractelement <4 x float> %r13.vec, i32 2
Instruction does not dominate all uses!
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
  %r13.extracted.t1 = extractelement <4 x float> %r13.vec, i32 1
Instruction does not dominate all uses!
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
  %r13.extracted.t0 = extractelement <4 x float> %r13.vec, i32 0
Instruction does not dominate all uses!
  %r13.extracted.t0 = extractelement <4 x float> %r13.vec, i32 0
  store float %r13.extracted.t0, float* %rt12, align 4
Instruction does not dominate all uses!
  %r13.extracted.t3 = extractelement <4 x float> %r13.vec, i32 3
  store float %r13.extracted.t3, float* %rt12.t3, align 4
Instruction does not dominate all uses!
  %r13.extracted.t2 = extractelement <4 x float> %r13.vec, i32 2
  store float %r13.extracted.t2, float* %rt12.t2, align 4
Instruction does not dominate all uses!
  %r13.extracted.t1 = extractelement <4 x float> %r13.vec, i32 1
  store float %r13.extracted.t1, float* %rt12.t1, align 4
Broken module found, verification continues.
cudaSetDevice() - 0 - Ocelot Dynamic Multicore CPU 
verification failed for translated function for copyFromGlobal : ""
LLVMDynamicTranslationCache.cpp:1244:

define internal void @_subkernel_copyFromGlobal_1_opt1_ws4(%LLVMContext* %__ctaContext) nounwind align 1 {
SchedulerEntry:
  %0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %threadId.x.t0 = load i32* %0
  %1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %threadId.y.t0 = load i32* %1
  %2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 2
  %threadId.z.t0 = load i32* %2
  %3 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %blockDim.x.t0 = load i32* %3
  %4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %blockDim.y.t0 = load i32* %4
  %5 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 2
  %blockDim.z.t0 = load i32* %5
  %6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %blockId.x.t0 = load i32* %6
  %7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %blockId.y.t0 = load i32* %7
  %8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 2
  %blockId.z.t0 = load i32* %8
  %9 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 0
  %gridDim.x.t0 = load i32* %9
  %10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 1
  %gridDim.y.t0 = load i32* %10
  %11 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 3, i32 2
  %gridDim.z.t0 = load i32* %11
  %localPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %localPtr.t0 = load i8** %localPtrPtr.t0
  %sharedPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 5
  %sharedPtr.t0 = load i8** %sharedPtrPtr.t0
  %constPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 6
  %constPtr.t0 = load i8** %constPtrPtr.t0
  %paramPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 7
  %paramPtr.t0 = load i8** %paramPtrPtr.t0
  %argumentPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %argumentPtr.t0 = load i8** %argumentPtrPtr.t0
  %metadataPtrPtr.t0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 9
  %metadataPtr.t0 = load i8** %metadataPtrPtr.t0
  %bitcast = bitcast i8* %localPtr.t0 to i32*
  %encodedResumePoint = load i32* %bitcast
  %resumePoint = and i32 %encodedResumePoint, 65535
  %12 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 0
  %threadId.x.t1 = load i32* %12
  %13 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 1
  %threadId.y.t1 = load i32* %13
  %14 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 0, i32 2
  %threadId.z.t1 = load i32* %14
  %15 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 0
  %blockDim.x.t1 = load i32* %15
  %16 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 1
  %blockDim.y.t1 = load i32* %16
  %17 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 1, i32 2
  %blockDim.z.t1 = load i32* %17
  %18 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 0
  %blockId.x.t1 = load i32* %18
  %19 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 1
  %blockId.y.t1 = load i32* %19
  %20 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 2, i32 2
  %blockId.z.t1 = load i32* %20
  %21 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 0
  %gridDim.x.t1 = load i32* %21
  %22 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 1
  %gridDim.y.t1 = load i32* %22
  %23 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 3, i32 2
  %gridDim.z.t1 = load i32* %23
  %localPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 4
  %localPtr.t1 = load i8** %localPtrPtr.t1
  %sharedPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 5
  %sharedPtr.t1 = load i8** %sharedPtrPtr.t1
  %constPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 6
  %constPtr.t1 = load i8** %constPtrPtr.t1
  %paramPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 7
  %paramPtr.t1 = load i8** %paramPtrPtr.t1
  %argumentPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 8
  %argumentPtr.t1 = load i8** %argumentPtrPtr.t1
  %metadataPtrPtr.t1 = getelementptr %LLVMContext* %__ctaContext, i32 1, i32 9
  %metadataPtr.t1 = load i8** %metadataPtrPtr.t1
  %24 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 0
  %threadId.x.t2 = load i32* %24
  %25 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 1
  %threadId.y.t2 = load i32* %25
  %26 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 0, i32 2
  %threadId.z.t2 = load i32* %26
  %27 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 0
  %blockDim.x.t2 = load i32* %27
  %28 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 1
  %blockDim.y.t2 = load i32* %28
  %29 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 1, i32 2
  %blockDim.z.t2 = load i32* %29
  %30 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 0
  %blockId.x.t2 = load i32* %30
  %31 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 1
  %blockId.y.t2 = load i32* %31
  %32 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 2, i32 2
  %blockId.z.t2 = load i32* %32
  %33 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 0
  %gridDim.x.t2 = load i32* %33
  %34 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 1
  %gridDim.y.t2 = load i32* %34
  %35 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 3, i32 2
  %gridDim.z.t2 = load i32* %35
  %localPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 4
  %localPtr.t2 = load i8** %localPtrPtr.t2
  %sharedPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 5
  %sharedPtr.t2 = load i8** %sharedPtrPtr.t2
  %constPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 6
  %constPtr.t2 = load i8** %constPtrPtr.t2
  %paramPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 7
  %paramPtr.t2 = load i8** %paramPtrPtr.t2
  %argumentPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 8
  %argumentPtr.t2 = load i8** %argumentPtrPtr.t2
  %metadataPtrPtr.t2 = getelementptr %LLVMContext* %__ctaContext, i32 2, i32 9
  %metadataPtr.t2 = load i8** %metadataPtrPtr.t2
  %36 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 0
  %threadId.x.t3 = load i32* %36
  %insert.threadId.x.t0.vec = insertelement <4 x i32> undef, i32 %threadId.x.t0, i32 0
  %insert.threadId.x.t1.vec = insertelement <4 x i32> %insert.threadId.x.t0.vec, i32 %threadId.x.t1, i32 1
  %insert.threadId.x.t2.vec = insertelement <4 x i32> %insert.threadId.x.t1.vec, i32 %threadId.x.t2, i32 2
  %insert.threadId.x.t3.vec = insertelement <4 x i32> %insert.threadId.x.t2.vec, i32 %threadId.x.t3, i32 3
  %37 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 1
  %threadId.y.t3 = load i32* %37
  %38 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 0, i32 2
  %threadId.z.t3 = load i32* %38
  %39 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 0
  %blockDim.x.t3 = load i32* %39
  %insert.blockDim.x.t0.vec = insertelement <4 x i32> undef, i32 %blockDim.x.t0, i32 0
  %insert.blockDim.x.t1.vec = insertelement <4 x i32> %insert.blockDim.x.t0.vec, i32 %blockDim.x.t1, i32 1
  %insert.blockDim.x.t2.vec = insertelement <4 x i32> %insert.blockDim.x.t1.vec, i32 %blockDim.x.t2, i32 2
  %insert.blockDim.x.t3.vec = insertelement <4 x i32> %insert.blockDim.x.t2.vec, i32 %blockDim.x.t3, i32 3
  %40 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 1
  %blockDim.y.t3 = load i32* %40
  %41 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 1, i32 2
  %blockDim.z.t3 = load i32* %41
  %42 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 0
  %blockId.x.t3 = load i32* %42
  %insert.blockId.x.t0.vec = insertelement <4 x i32> undef, i32 %blockId.x.t0, i32 0
  %insert.blockId.x.t1.vec = insertelement <4 x i32> %insert.blockId.x.t0.vec, i32 %blockId.x.t1, i32 1
  %insert.blockId.x.t2.vec = insertelement <4 x i32> %insert.blockId.x.t1.vec, i32 %blockId.x.t2, i32 2
  %insert.blockId.x.t3.vec = insertelement <4 x i32> %insert.blockId.x.t2.vec, i32 %blockId.x.t3, i32 3
  %43 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 1
  %blockId.y.t3 = load i32* %43
  %44 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 2, i32 2
  %blockId.z.t3 = load i32* %44
  %45 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 0
  %gridDim.x.t3 = load i32* %45
  %46 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 1
  %gridDim.y.t3 = load i32* %46
  %47 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 3, i32 2
  %gridDim.z.t3 = load i32* %47
  %localPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 4
  %localPtr.t3 = load i8** %localPtrPtr.t3
  %sharedPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 5
  %sharedPtr.t3 = load i8** %sharedPtrPtr.t3
  %constPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 6
  %constPtr.t3 = load i8** %constPtrPtr.t3
  %paramPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 7
  %paramPtr.t3 = load i8** %paramPtrPtr.t3
  %argumentPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 8
  %argumentPtr.t3 = load i8** %argumentPtrPtr.t3
  %metadataPtrPtr.t3 = getelementptr %LLVMContext* %__ctaContext, i32 3, i32 9
  %metadataPtr.t3 = load i8** %metadataPtrPtr.t3
  switch i32 %resumePoint, label %"$BB_1_0002" [
  ]

"$BB_1_0002":                                     ; preds = %SchedulerEntry
  %rt2 = bitcast i8* %argumentPtr.t0 to i64*
  %rt2.t3 = bitcast i8* %argumentPtr.t3 to i64*
  %rt2.t2 = bitcast i8* %argumentPtr.t2 to i64*
  %rt2.t1 = bitcast i8* %argumentPtr.t1 to i64*
  %r0 = load i64* %rt2, align 8
  %r0.t3 = load i64* %rt2.t3, align 8
  %r0.t2 = load i64* %rt2.t2, align 8
  %r0.t1 = load i64* %rt2.t1, align 8
  %rt9.vec = mul <4 x i32> %insert.blockId.x.t3.vec, %insert.blockDim.x.t3.vec
  %r5.vec = add <4 x i32> %insert.threadId.x.t3.vec, %rt9.vec
  %r5.extracted.t3 = extractelement <4 x i32> %r5.vec, i32 3
  %r5.extracted.t2 = extractelement <4 x i32> %r5.vec, i32 2
  %r5.extracted.t1 = extractelement <4 x i32> %r5.vec, i32 1
  %r5.extracted.t0 = extractelement <4 x i32> %r5.vec, i32 0
  %r6 = load float* @Pi, align 4
  %r6.t3 = load float* @Pi, align 4
  %insert.r6.vec = insertelement <4 x float> undef, float %r6, i32 0
  %insert.r6.t1.vec = insertelement <4 x float> %insert.r6.vec, float %r6.t1, i32 1
  %insert.r6.t2.vec = insertelement <4 x float> %insert.r6.t1.vec, float %r6.t2, i32 2
  %insert.r6.t3.vec = insertelement <4 x float> %insert.r6.t2.vec, float %r6.t3, i32 3
  %r6.t2 = load float* @Pi, align 4
  %r6.t1 = load float* @Pi, align 4
  %48 = insertelement <4 x i32> undef, i32 31, i32 0
  %49 = insertelement <4 x i32> %48, i32 31, i32 1
  %50 = insertelement <4 x i32> %49, i32 31, i32 2
  %51 = insertelement <4 x i32> %50, i32 31, i32 3
  %r7.vec = ashr <4 x i32> %r5.vec, %51
  %52 = insertelement <4 x i32> undef, i32 25, i32 0
  %53 = insertelement <4 x i32> %52, i32 25, i32 1
  %54 = insertelement <4 x i32> %53, i32 25, i32 2
  %55 = insertelement <4 x i32> %54, i32 25, i32 3
  %r8.vec = lshr <4 x i32> %r7.vec, %55
  %r9.vec = add <4 x i32> %r5.vec, %r8.vec
  %56 = insertelement <4 x i32> undef, i32 -128, i32 0
  %57 = insertelement <4 x i32> %56, i32 -128, i32 1
  %58 = insertelement <4 x i32> %57, i32 -128, i32 2
  %59 = insertelement <4 x i32> %58, i32 -128, i32 3
  %r10.vec = and <4 x i32> %r9.vec, %59
  %r11.vec = sub <4 x i32> %r5.vec, %r10.vec
  %r11.extracted.t3 = extractelement <4 x i32> %r11.vec, i32 3
  %r11.extracted.t2 = extractelement <4 x i32> %r11.vec, i32 2
  %r11.extracted.t1 = extractelement <4 x i32> %r11.vec, i32 1
  %r11.extracted.t0 = extractelement <4 x i32> %r11.vec, i32 0
  %r12 = sitofp i32 %r11.extracted.t0 to float
  %r12.t3 = sitofp i32 %r11.extracted.t3 to float
  %insert.r12.vec = insertelement <4 x float> undef, float %r12, i32 0
  %insert.r12.t1.vec = insertelement <4 x float> %insert.r12.vec, float %r12.t1, i32 1
  %insert.r12.t2.vec = insertelement <4 x float> %insert.r12.t1.vec, float %r12.t2, i32 2
  %insert.r12.t3.vec = insertelement <4 x float> %insert.r12.t2.vec, float %r12.t3, i32 3
  %r12.t2 = sitofp i32 %r11.extracted.t2 to float
  %r12.t1 = sitofp i32 %r11.extracted.t1 to float
  %r13.vec = fmul <4 x float> %insert.r6.t3.vec, %insert.r12.t3.vec
  %r13.extracted.t3 = extractelement <4 x float> %r13.vec, i32 3
  %r13.extracted.t2 = extractelement <4 x float> %r13.vec, i32 2
  %r13.extracted.t1 = extractelement <4 x float> %r13.vec, i32 1
  %r13.extracted.t0 = extractelement <4 x float> %r13.vec, i32 0
  %rt11 = sext i32 %r5.extracted.t0 to i64
  %rt11.t3 = sext i32 %r5.extracted.t3 to i64
  %rt11.t2 = sext i32 %r5.extracted.t2 to i64
  %rt11.t1 = sext i32 %r5.extracted.t1 to i64
  %r14 = mul i64 %rt11, 4
  %r14.t3 = mul i64 %rt11.t3, 4
  %r14.t2 = mul i64 %rt11.t2, 4
  %r14.t1 = mul i64 %rt11.t1, 4
  %r15 = add i64 %r0, %r14
  %r15.t3 = add i64 %r0.t3, %r14.t3
  %r15.t2 = add i64 %r0.t2, %r14.t2
  %r15.t1 = add i64 %r0.t1, %r14.t1
  %rt12 = inttoptr i64 %r15 to float*
  %rt12.t3 = inttoptr i64 %r15.t3 to float*
  %rt12.t2 = inttoptr i64 %r15.t2 to float*
  %rt12.t1 = inttoptr i64 %r15.t1 to float*
  store float %r13.extracted.t0, float* %rt12, align 4
  store float %r13.extracted.t3, float* %rt12.t3, align 4
  store float %r13.extracted.t2, float* %rt12.t2, align 4
  store float %r13.extracted.t1, float* %rt12.t1, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002"
  ret void
}


error on subkernel: _Z_ocelotTranslated__subkernel_copyFromGlobal_1
 specialization: _subkernel_copyFromGlobal_1_opt1_ws4
TestCudaGlobals: ocelot/executive/implementation/DynamicTranslationCache.cpp:1253: void cloneAndOptimizeTranslation(executive::DynamicTranslationCache::TranslatedKernel&, executive::DynamicTranslationCache::TranslatedSubkernel&, executive::DynamicTranslationCache::SubkernelId, executive::DynamicTranslationCache::Translation*, int, translator::Translator::OptimizationLevel, unsigned int, bool): Assertion `0 && "due to broken LLVM translation"' failed.

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDataflowGraph -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestEmulator
INFO     Test completed in 0.0528130531311 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestEmulator

Description: 


Test Seed : 1335814028
Test time : 0.00379729

Status : Test output:
10 registers
Register test passed
Load test passed
Store test passed
no errors
Full kernel test passed



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXAssembly
INFO     Test completed in 0.0828990936279 seconds
INFO      It produced the following output:
Pass/Fail : Fail


Name : TestPTXAssembly

Description: A unit test framework for PTX. Runs random inputs through unit 
             tests on all available devices until a timer expires.


Test Seed : 1335814028
Test time : 0.0361397

Status : Ran 'TestVectorElements-u32' for 16 iterations.
 Output parameter 0 (I16) computed value - -27056 does not match reference value - -4279
  On device - 0 - 'Ocelot Dynamic Multicore CPU'
Test 'TestAdd-u16' seed '1335814028' failed.



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDataflowGraph
INFO     Test completed in 0.0457010269165 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestDataflowGraph

Description: A test for the DataflowGraph class. Test Points: 1) 
             Generic: load PTX files, convert them into dataflow graphs, verify that 
             all live ranges spanning blocks are consistent. 2) SSA: convert to 
             ssa form, verify that no register is declared more than once. 3) 
             reverse SSA: convert to ssa then out of ssa, verify that all live 
             ranges spanning blocks are consistent.


Test Seed : 1335814028
Test time : 1.57356e-05

Status : Testing Generic Dataflow
 Test Passed
Testing SSA Dataflow
 Test Passed
Testing SSA then back Dataflow
 Test Passed



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaMalloc
INFO     Test completed in 0.0749449729919 seconds
INFO      It produced the following output:
test_malloc(256, 128)
PASSED
test_mallocArray(256, 128)
checking results from last cudaMemcpyFromArray
PASSED
[1] mallocing pitch
[2] memcpying2d
[3] memcpying
[4] checking for errors
[5] mallocing
[6] memcpying
[7] memcpying
[8] final free
Pass/Fail : Pass

INFO     
Passing tests:
 (0.046s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDataflowGraph : Passed
 (0.111s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMKernels : Passed
 (0.058s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLexer : Passed
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXToLLVMTranslator : Passed
 (0.075s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaMalloc : Passed
 (0.053s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestEmulator : Passed
 (0.059s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestParser : Passed
 (0.066s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestDeviceSwitching : Passed
 (0.050s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestInstructions : Passed
 (0.047s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestLLVMInstructions : Passed
 (0.045s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCalVectorScale : Passed
 (0.063s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestKernels : Passed

Failing tests:
 (0.072s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaSequence : Did not complete.
 (0.084s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTexture2D : Did not complete.
 (0.043s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestIndirectFunctionCall : Did not complete.
 (0.081s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaGlobals : Did not complete.
 (0.069s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestCudaTextureArray : Did not complete.
 (0.041s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestExternalFunctions : Did not complete.
 (0.083s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestPTXAssembly : Failed
 (0.049s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-subkernel/.release_build/TestFunctionCall : Did not complete.

