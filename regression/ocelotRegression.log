INFO     Reading in test file /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/regression/ocelotRegressionTests.txt
INFO      Found the following tests:
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLexer
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestParser
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestEmulator
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestInstructions
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestKernels
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDataflowGraph
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMInstructions
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMKernels
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaMalloc
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTexture2D
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTextureArray
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaGlobals
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDeviceSwitching
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaSequence
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCalVectorScale
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXAssembly
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestFunctionCall
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestIndirectFunctionCall
INFO       /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestConvergence
INFO     ==== INDIVIDUAL TEST RESULTS ====

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestInstructions 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDataflowGraph -i ../tests/ptx 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaGlobals 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMKernels 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDataflowGraph
INFO     Test completed in 0.0331571102142 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestDataflowGraph

Description: A test for the DataflowGraph class. Test Points: 1) 
             Generic: load PTX files, convert them into dataflow graphs, verify that 
             all live ranges spanning blocks are consistent. 2) SSA: convert to 
             ssa form, verify that no register is declared more than once. 3) 
             reverse SSA: convert to ssa then out of ssa, verify that all live 
             ranges spanning blocks are consistent.


Test Seed : 1315344563
Test time : 1.50204e-05

Status : Testing Generic Dataflow
 Test Passed
Testing SSA Dataflow
 Test Passed
Testing SSA then back Dataflow
 Test Passed



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCalVectorScale 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestInstructions
INFO     Test completed in 0.0397419929504 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestInstructions

Description: 


Test Seed : 1315344563
Test time : 0.000490427

Status : Test output:
Accessors test passed.
pass: load and store instructions
Abs test passed.
pass: arithmetic instructions
pass: exotic arithmetic instructions
pass: floating-point instructions
pass: logical instructions
pass: comparison instructions
pass: predicated Add and Ld isntructions
pass: control flow instructions



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestFunctionCall 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaGlobals
INFO     Test completed in 0.0431799888611 seconds
INFO      It produced the following output:
cudaSetDevice() - 0 - Ocelot Dynamic Multicore CPU Backend (LLVM-JIT) 
(0.002379) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - global.cu
(0.002397) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'copyFromGlobal'
(0.004164) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.004173) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896

@Pi = external global float, align 4;

%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_copyFromGlobal( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt5 = load i32* %rt4;
	%r2 = bitcast i32 %rt5 to i32;
	%r3 = mul i32 %r1, %r2;
	%r4 = add i32 %r0, %r3;
	%r5 = ashr i32 %r4, 31;
	%r6 = bitcast i32 127 to i32;
	%r7 = and i32 %r5, %r6;
	%r8 = add i32 %r7, %r4;
	%r9 = ashr i32 %r8, 7;
	%r10 = mul i32 %r9, 128;
	%r11 = sub i32 %r4, %r10;
	%r12 = sitofp i32 %r11 to float;
	%rt6 = bitcast float* @Pi to float*;
	%r13 = load float* %rt6, align 4;
	%r14 = fmul float %r12, %r13;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt8 = load i8** %rt7;
	%rt9 = bitcast i8* %rt8 to i64*;
	%r15 = load i64* %rt9, align 8;
	%r16 = sext i32 %r4 to i64;
	%rt10 = sext i32 %r4 to i64;
	%r17 = mul i64 %rt10, 4;
	%r18 = add i64 %r15, %r17;
	%rt11 = inttoptr i64 %r18 to float*;
	store float %r14, float* %rt11, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r19 = bitcast i32 0 to i32;
	%rt12 = zext i32 %r19 to i64;
	%rt13 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt14 = load i8** %rt13;
	%rt15 = ptrtoint i8* %rt14 to i64;
	%rt16 = add i64 %rt12, %rt15;
	%rt17 = inttoptr i64 %rt16 to i32*;
	store i32 6, i32* %rt17, align 4;
	br label %exit;
exit:
	ret void;

}

(0.005178) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.005188) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.005200) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.005333) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_copyFromGlobal_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_1_0002":
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %rt1 = load i32* %rt0
  %r0 = bitcast i32 %rt1 to i32
  %rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %rt3 = load i32* %rt2
  %r1 = bitcast i32 %rt3 to i32
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %rt5 = load i32* %rt4
  %r2 = bitcast i32 %rt5 to i32
  %r3 = mul i32 %r1, %r2
  %r4 = add i32 %r0, %r3
  %r5 = ashr i32 %r4, 31
  %r6 = bitcast i32 127 to i32
  %r7 = and i32 %r5, %r6
  %r8 = add i32 %r7, %r4
  %r9 = ashr i32 %r8, 7
  %r10 = mul i32 %r9, 128
  %r11 = sub i32 %r4, %r10
  %r12 = sitofp i32 %r11 to float
  %rt6 = bitcast float* @Pi to float*
  %r13 = load float* %rt6, align 4
  %r14 = fmul float %r12, %r13
  %rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt8 = load i8** %rt7
  %rt9 = bitcast i8* %rt8 to i64*
  %r15 = load i64* %rt9, align 8
  %r16 = sext i32 %r4 to i64
  %rt10 = sext i32 %r4 to i64
  %r17 = mul i64 %rt10, 4
  %r18 = add i64 %r15, %r17
  %rt11 = inttoptr i64 %r18 to float*
  store float %r14, float* %rt11, align 4
  br i1 true, label %"$BB_1_0002_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; preds = %"$BB_1_0002"
  %r19 = bitcast i32 0 to i32
  %rt12 = zext i32 %r19 to i64
  %rt13 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt14 = load i8** %rt13
  %rt15 = ptrtoint i8* %rt14 to i64
  %rt16 = add i64 %rt12, %rt15
  %rt17 = inttoptr i64 %rt16 to i32*
  store i32 6, i32* %rt17, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002_exit", %"$BB_1_0002"
  ret void
}



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMInstructions 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMKernels
INFO     Test completed in 0.0557827949524 seconds
INFO      It produced the following output:

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestParser -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestFunctionCall
INFO     Test completed in 0.0360851287842 seconds
INFO      It produced the following output:
(0.002600) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - simpleFunc.cu
(0.002626) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'square'
(0.002798) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'kernel'
(0.004261) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.004270) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_square( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt2 = load i8** %rt1;
	%rt0 = getelementptr i8* %rt2, i32 4;
	%rt3 = bitcast i8* %rt0 to float*;
	%r0 = load float* %rt3, align 4;
	%r1 = bitcast float %r0 to float;
	%r2 = fmul float %r1, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt5 = load i8** %rt4;
	%rt6 = bitcast i8* %rt5 to float*;
	store float %r2, float* %rt6, align 4;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt8 = load i8** %rt7;
	%rt9 = bitcast i8* %rt8 to i32*;
	store i32 2, i32* %rt9;
	br label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	ret void;
exit:
	ret void;

}

(0.005129) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.005137) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.005144) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.005274) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_square_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_1_0002":
  %rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt2 = load i8** %rt1
  %rt0 = getelementptr i8* %rt2, i32 4
  %rt3 = bitcast i8* %rt0 to float*
  %r0 = load float* %rt3, align 4
  %r1 = bitcast float %r0 to float
  %r2 = fmul float %r1, %r1
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt5 = load i8** %rt4
  %rt6 = bitcast i8* %rt5 to float*
  store float %r2, float* %rt6, align 4
  %rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt8 = load i8** %rt7
  %rt9 = bitcast i8* %rt8 to i32*
  store i32 2, i32* %rt9
  br label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; No predecessors!
  ret void

exit:                                             ; preds = %"$BB_1_0002"
  ret void
}



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCalVectorScale
INFO     Test completed in 0.0426499843597 seconds
INFO      It produced the following output:
No CAL devices found
Pass/Fail : Pass

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTextureArray 
INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaSequence 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMInstructions
INFO     Test completed in 0.0355551242828 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLLVMInstructions

Description: A test for the assembly code generation and automatic 
             verfication of individual LLVM instructions. Test Points: 1) For each 
             instruction, generate several assembly strings using the 
             instruction's toString method, make sure that these pass the valid() 
             check, compare to references from the LLVM manual.


Test Seed : 1315344563
Test time : 0.000723362

Status :  Checked instruction "<result> = add i32 4, %var"
Add Instruction Passed
 Checked instruction "%ptr = alloca i32"
 Checked instruction "%ptr = alloca i32, i32 4"
 Checked instruction "%ptr = alloca i32, i32 4, align 1024"
 Checked instruction "%ptr = alloca i32, align 1024"
Alloca Instruction Passed
 Checked instruction "<result> = and i32 4, %var"
 Checked instruction "<result> = and i32 15, 40"
 Checked instruction "<result> = and i32 4, 8"
And Instruction Passed
 Checked instruction "<result> = ashr i32 4, 1"
 Checked instruction "<result> = ashr i8 -2, 1"
 Checked instruction "<result> = ashr < 2 x i32 > < i32 -2, i32 4 >, < i32 1, i32 3 >"
Ashr Instruction Passed
 Checked instruction "%X = bitcast i8 -1 to i8"
 Checked instruction "%Z = bitcast < 2 x i32 > %V to i64"
Bitcast Instruction Passed
 Checked instruction "br i1 %cond, label %IfEqual, label %IfUnequal"
Br Instruction Passed
 Checked instruction "%retval = call i32 @test(i32 %argc)"
 Checked instruction "call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)"
 Checked instruction "%X = tail call i32 @foo()"
 Checked instruction "%Y = tail call fastcc i32 @foo()"
 Checked instruction "call void @foo(i8 97 signext)"
 Checked instruction "%r = call %struct.A @foo()"
 Checked instruction "call void @foo() noreturn"
 Checked instruction "%ZZ = call zeroext i32 @bar()"
Call Instruction Passed
 Checked instruction "%result = extractelement < 4 x i32 > %vec, i32 0"
Extractelement Instruction Passed
 Checked instruction "%result = extractvalue { i32, float } %agg, 0"
Extractvalue Instruction Passed
 Checked instruction "<result> = fadd float 0x4010000000000000, %var"
Fadd Instruction Passed
 Checked instruction "<result> = fcmp oeq float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp one float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp olt float 0x4010000000000000, 0x4014000000000000"
 Checked instruction "<result> = fcmp ueq float 0x3ff0000000000000, 0x4000000000000000"
Fcmp Instruction Passed
 Checked instruction "<result> = fdiv float 0x4010000000000000, %var"
Fdiv Instruction Passed
 Checked instruction "<result> = fmul float 0x4010000000000000, %var"
Fmul Instruction Passed
 Checked instruction "%X = fpext float 0x400921cac0000000 to double"
 Checked instruction "%Y = fpext float 0x3ff0000000000000 to float"
Fpext Instruction Passed
 Checked instruction "%X = fptosi double 0xc05ec00000000000 to i32"
Fptosi Instruction Passed
 Checked instruction "%X = fptoui double 0x405ec00000000000 to i32"
Fptoui Instruction Passed
 Checked instruction "%X = fptrunc double 0x405ec00000000000 to float"
Fptrunc Instruction Passed
 Checked instruction "free [ 4 x i8 ]* %array"
Free Instruction Passed
 Checked instruction "<result> = frem float 0x4010000000000000, %var"
Frem Instruction Passed
 Checked instruction "<result> = fsub float 0x0, %val"
Fsub Instruction Passed
 Checked instruction "%vptr = getelementptr { i32, < 2 x i8 > }* %svptr, i32 0, i32 1, i32 1"
 Checked instruction "%eptr = getelementptr [ 12 x i8 ]* %aptr, i32 0, i32 1"
Getelementptr Instruction Passed
 Checked instruction "<result> = icmp ne float* %X, %X"
Icmp Instruction Passed
 Checked instruction "%result = insertelement < 4 x i32 > %vec, i32 1, i32 0"
Insertelement Instruction Passed
 Checked instruction "%result = insertvalue { i32, float } %agg, i32 1, 0"
Insertvalue Instruction Passed
 Checked instruction "%Y = inttoptr i64 0 to i32*"
Inttoptr Instruction Passed
 Checked instruction "%retval = invoke i32 @Test(i32 15) to label %Continue unwind label %TestCleanup"
Invoke Instruction Passed
 Checked instruction "%val = load i32* %ptr"
Load Instruction Passed
 Checked instruction "<result> = lshr i8 -2, 1"
Lshr Instruction Passed
 Checked instruction "%array2 = malloc [ 12 x i8 ], i32 %size"
Malloc Instruction Passed
 Checked instruction "<result> = mul i32 4, %var"
Mul Instruction Passed
 Checked instruction "<result> = or i32 15, 40"
Or Instruction Passed
 Checked instruction "%indvar = phi i32 [ 0, %LoopHeader ], [ %nextindvar, %Loop ]"
Phi Instruction Passed
 Checked instruction "%Y = ptrtoint i32* %x to i64"
Prtoint Instruction Passed
 Checked instruction "ret void"
Ret Instruction Passed
 Checked instruction "<result> = sdiv i32 4, %var"
Sdiv Instruction Passed
 Checked instruction "%X = select i1 1, i8 17, i8 42"
Select Instruction Passed
 Checked instruction "%X = sext i8 -1 to i16"
Sext Instruction Passed
 Checked instruction "<result> = shl i32 1, 32"
Shl Instruction Passed
 Checked instruction "%result = shufflevector < 4 x i32 > %v1, < 4 x i32 > %v2, < 8 x i32 > < i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7 >"
ShuffleVector Instruction Passed
 Checked instruction "%X = sitofp i32 257 to float"
Sitofp Instruction Passed
 Checked instruction "<result> = srem i32 4, %var"
Srem Instruction Passed
 Checked instruction "store i32 3, i32* %ptr"
Store Instruction Passed
 Checked instruction "<result> = sub i32 4, %var"
Sub Instruction Passed
 Checked instruction "switch i32 %val, label %otherwise [ i32 0, label %onzero i32 1, label %onone i32 2, label %ontwo ]"
Switch Instruction Passed
 Checked instruction "%Y = trunc i32 123 to i1"
Trunc Instruction Passed
 Checked instruction "<result> = udiv i32 4, %var"
Udiv Instruction Passed
 Checked instruction "%Y = uitofp i8 -1 to double"
Uitofp Instruction Passed
 Checked instruction "unreachable"
Unreachable Instruction Passed
 Checked instruction "unwind"
Unwind Instruction Passed
 Checked instruction "<result> = urem i32 4, %var"
Urem Instruction Passed
 Checked instruction "%tmp = va_arg i8** %ap, i32"
VarArg Instruction Passed
 Checked instruction "<result> = xor i32 -1, %V"
Xor Instruction Passed
 Checked instruction "%X = zext i32 257 to i64"
Zext Instruction Passed



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestEmulator 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestParser
INFO     Test completed in 0.0361039638519 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestParser

Description: A test for the PTXParser class. Test Points: 1) Load a PTX file 
             and run it through the parser generating a module. Write the 
             module to an intermediate stream. Parse the stream again 
             generating a new module, compare both to make sure that they match.


Test Seed : 1315344563
Test time : 1.85966e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTextureArray
INFO     Test completed in 0.0394310951233 seconds
INFO      It produced the following output:
(0.002487) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - textureArray.cu
(0.002513) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel '_Z6kernelPfii'
(0.004546) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.004555) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated__Z6kernelPfii( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$OcelotTextureAllocateBlock:
	%integerTexture = alloca i32, i32 4, align 16;
	%floatingPointTexture = alloca float, i32 4, align 16;
	br label %$BB_1_0002;
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%r2 = mul i32 %r0, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1;
	%rt5 = load i32* %rt4;
	%r3 = bitcast i32 %rt5 to i32;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1;
	%rt7 = load i32* %rt6;
	%r4 = bitcast i32 %rt7 to i32;
	%r5 = mul i32 %r3, %r4;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt9 = load i32* %rt8;
	%r6 = bitcast i32 %rt9 to i32;
	%r7 = add i32 %r6, %r2;
	%rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1;
	%rt11 = load i32* %rt10;
	%r8 = bitcast i32 %rt11 to i32;
	%r9 = add i32 %r8, %r5;
	%r10 = uitofp i32 %r7 to float;
	%r11 = uitofp i32 %r9 to float;
	%r12 = bitcast float 0x0 to float;
	%r13 = bitcast float 0x0 to float;
	call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11);
	%r14 = load float* %floatingPointTexture;
	%rt12 = getelementptr float* %floatingPointTexture, i32 1;
	%r15 = load float* %rt12;
	%rt13 = getelementptr float* %floatingPointTexture, i32 2;
	%r16 = load float* %rt13;
	%rt14 = getelementptr float* %floatingPointTexture, i32 3;
	%r17 = load float* %rt14;
	%r18 = bitcast float %r14 to float;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt16 = load i8** %rt15;
	%rt17 = bitcast i8* %rt16 to i64*;
	%r19 = load i64* %rt17, align 8;
	%rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt20 = load i8** %rt19;
	%rt18 = getelementptr i8* %rt20, i32 8;
	%rt21 = bitcast i8* %rt18 to i32*;
	%r20 = load i32* %rt21, align 4;
	%r21 = mul i32 %r20, %r9;
	%r22 = add i32 %r7, %r21;
	%r23 = zext i32 %r22 to i64;
	%rt22 = zext i32 %r22 to i64;
	%r24 = mul i64 %rt22, 4;
	%r25 = add i64 %r19, %r24;
	%rt23 = inttoptr i64 %r25 to float*;
	store float %r18, float* %rt23, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r26 = bitcast i32 0 to i32;
	%rt24 = zext i32 %r26 to i64;
	%rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt26 = load i8** %rt25;
	%rt27 = ptrtoint i8* %rt26 to i64;
	%rt28 = add i64 %rt24, %rt27;
	%rt29 = inttoptr i64 %rt28 to i32*;
	store i32 6, i32* %rt29, align 4;
	br label %exit;
exit:
	ret void;

}

(0.005601) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.005610) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.005617) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.005758) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated__Z6kernelPfii_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$OcelotTextureAllocateBlock":
  %integerTexture = alloca i32, i32 4, align 16
  %floatingPointTexture = alloca float, i32 4, align 16
  br label %"$BB_1_0002"

"$BB_1_0002":                                     ; preds = %"$BB_1_0002_entry", %"$OcelotTextureAllocateBlock"
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %rt1 = load i32* %rt0
  %r0 = bitcast i32 %rt1 to i32
  %rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %rt3 = load i32* %rt2
  %r1 = bitcast i32 %rt3 to i32
  %r2 = mul i32 %r0, %r1
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %rt5 = load i32* %rt4
  %r3 = bitcast i32 %rt5 to i32
  %rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %rt7 = load i32* %rt6
  %r4 = bitcast i32 %rt7 to i32
  %r5 = mul i32 %r3, %r4
  %rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %rt9 = load i32* %rt8
  %r6 = bitcast i32 %rt9 to i32
  %r7 = add i32 %r6, %r2
  %rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %rt11 = load i32* %rt10
  %r8 = bitcast i32 %rt11 to i32
  %r9 = add i32 %r8, %r5
  %r10 = uitofp i32 %r7 to float
  %r11 = uitofp i32 %r9 to float
  %r12 = bitcast float 0.000000e+00 to float
  %r13 = bitcast float 0.000000e+00 to float
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11)
  %r14 = load float* %floatingPointTexture
  %rt12 = getelementptr float* %floatingPointTexture, i32 1
  %r15 = load float* %rt12
  %rt13 = getelementptr float* %floatingPointTexture, i32 2
  %r16 = load float* %rt13
  %rt14 = getelementptr float* %floatingPointTexture, i32 3
  %r17 = load float* %rt14
  %r18 = bitcast float %r14 to float
  %rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt16 = load i8** %rt15
  %rt17 = bitcast i8* %rt16 to i64*
  %r19 = load i64* %rt17, align 8
  %rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt20 = load i8** %rt19
  %rt18 = getelementptr i8* %rt20, i32 8
  %rt21 = bitcast i8* %rt18 to i32*
  %r20 = load i32* %rt21, align 4
  %r21 = mul i32 %r20, %r9
  %r22 = add i32 %r7, %r21
  %r23 = zext i32 %r22 to i64
  %rt22 = zext i32 %r22 to i64
  %r24 = mul i64 %rt22, 4
  %r25 = add i64 %r19, %r24
  %rt23 = inttoptr i64 %r25 to float*
  store float %r18, float* %rt23, align 4
  br i1 true, label %"$BB_1_0002_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; preds = %"$BB_1_0002"
  %r26 = bitcast i32 0 to i32
  %rt24 = zext i32 %r26 to i64
  %rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt26 = load i8** %rt25
  %rt27 = ptrtoint i8* %rt26 to i64
  %rt28 = add i64 %rt24, %rt27
  %rt29 = inttoptr i64 %rt28 to i32*
  store i32 6, i32* %rt29, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002_exit", %"$BB_1_0002"
  ret void
}



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXAssembly 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestEmulator
INFO     Test completed in 0.0363068580627 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestEmulator

Description: 


Test Seed : 1315344563
Test time : 0.00278163

Status : Test output:
10 registers
Register test passed
Load test passed
Store test passed
no errors
Full kernel test passed



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaMalloc 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator
INFO     Test completed in 0.0278720855713 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestPTXToLLVMTranslator

Description: This is a basic test that just tries to get through a 
             translation successfully of as many PTX programs as possible Test 
             Points: 1) Scan for all PTX files in a directory, try to 
             translate them.


Test Seed : 1315344563
Test time : 1.07288e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDeviceSwitching 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaSequence
INFO     Test completed in 0.0640568733215 seconds
INFO      It produced the following output:
Loaded libcuda.so explicitly; unloading now.
A_host = 0x19be400
A_gpu = 0x19bac00
(0.011833) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - sequence.cu
(0.011858) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'v4sequence'
(0.012383) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'testShareSimple'
(0.013050) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'testShr'
(0.014100) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'testShareConvergent'
(0.014686) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'sequence'
(0.016995) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.017018) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_v4sequence( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_4_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt5 = load i32* %rt4;
	%r2 = bitcast i32 %rt5 to i32;
	%r3 = mul i32 %r1, %r2;
	%r4 = add i32 %r0, %r3;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt7 = load i8** %rt6;
	%rt8 = bitcast i8* %rt7 to i64*;
	%r5 = load i64* %rt8, align 8;
	%r6 = sext i32 %r4 to i64;
	%rt9 = sext i32 %r4 to i64;
	%r7 = mul i64 %rt9, 16;
	%r8 = add i64 %r5, %r7;
	%r9 = add i32 %r4, 1;
	%r10 = mul i32 %r4, 2;
	%r11 = add i32 %r10, 2;
	%r12 = mul i32 %r4, 3;
	%r13 = add i32 %r12, 3;
	%r14 = mul i32 %r4, 4;
	%r15 = add i32 %r14, 4;
	%rt10 = inttoptr i64 %r8 to < 4 x i32 >*;
	%rt12 = bitcast i32 %r9 to i32;
	%rt11 = insertelement < 4 x i32 > < i32 0, i32 0, i32 0, i32 0 >, i32 %rt12, i32 0;
	%rt14 = bitcast i32 %r11 to i32;
	%rt13 = insertelement < 4 x i32 > %rt11, i32 %rt14, i32 1;
	%rt16 = bitcast i32 %r13 to i32;
	%rt15 = insertelement < 4 x i32 > %rt13, i32 %rt16, i32 2;
	%rt18 = bitcast i32 %r15 to i32;
	%rt17 = insertelement < 4 x i32 > %rt15, i32 %rt18, i32 3;
	store < 4 x i32 > %rt17, < 4 x i32 >* %rt10, align 16;
	br i1 1, label %$BB_4_0002_exit, label %exit;
$BB_4_0002_entry:
	br label %$BB_4_0002;
$BB_4_0002_exit:
	%r16 = bitcast i32 0 to i32;
	%rt19 = zext i32 %r16 to i64;
	%rt20 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt21 = load i8** %rt20;
	%rt22 = ptrtoint i8* %rt21 to i64;
	%rt23 = add i64 %rt19, %rt22;
	%rt24 = inttoptr i64 %rt23 to i32*;
	store i32 6, i32* %rt24, align 4;
	br label %exit;
exit:
	ret void;

}

(0.018258) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.018269) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.018276) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.018413) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_v4sequence_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_4_0002":
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %rt1 = load i32* %rt0
  %r0 = bitcast i32 %rt1 to i32
  %rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %rt3 = load i32* %rt2
  %r1 = bitcast i32 %rt3 to i32
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %rt5 = load i32* %rt4
  %r2 = bitcast i32 %rt5 to i32
  %r3 = mul i32 %r1, %r2
  %r4 = add i32 %r0, %r3
  %rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt7 = load i8** %rt6
  %rt8 = bitcast i8* %rt7 to i64*
  %r5 = load i64* %rt8, align 8
  %r6 = sext i32 %r4 to i64
  %rt9 = sext i32 %r4 to i64
  %r7 = mul i64 %rt9, 16
  %r8 = add i64 %r5, %r7
  %r9 = add i32 %r4, 1
  %r10 = mul i32 %r4, 2
  %r11 = add i32 %r10, 2
  %r12 = mul i32 %r4, 3
  %r13 = add i32 %r12, 3
  %r14 = mul i32 %r4, 4
  %r15 = add i32 %r14, 4
  %rt10 = inttoptr i64 %r8 to <4 x i32>*
  %rt12 = bitcast i32 %r9 to i32
  %rt11 = insertelement <4 x i32> zeroinitializer, i32 %rt12, i32 0
  %rt14 = bitcast i32 %r11 to i32
  %rt13 = insertelement <4 x i32> %rt11, i32 %rt14, i32 1
  %rt16 = bitcast i32 %r13 to i32
  %rt15 = insertelement <4 x i32> %rt13, i32 %rt16, i32 2
  %rt18 = bitcast i32 %r15 to i32
  %rt17 = insertelement <4 x i32> %rt15, i32 %rt18, i32 3
  store <4 x i32> %rt17, <4 x i32>* %rt10, align 16
  br i1 true, label %"$BB_4_0002_exit", label %exit

"$BB_4_0002_entry":                               ; No predecessors!
  br label %"$BB_4_0002"

"$BB_4_0002_exit":                                ; preds = %"$BB_4_0002"
  %r16 = bitcast i32 0 to i32
  %rt19 = zext i32 %r16 to i64
  %rt20 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt21 = load i8** %rt20
  %rt22 = ptrtoint i8* %rt21 to i64
  %rt23 = add i64 %rt19, %rt22
  %rt24 = inttoptr i64 %rt23 to i32*
  store i32 6, i32* %rt24, align 4
  br label %exit

exit:                                             ; preds = %"$BB_4_0002_exit", %"$BB_4_0002"
  ret void
}



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLexer -i ../tests/ptx 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXAssembly
INFO     Test completed in 0.0391762256622 seconds
INFO      It produced the following output:
(0.003892) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - TestVectorElements-u32
(0.003917) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'test'
(0.005397) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.005405) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_test( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt2 = load i8** %rt1;
	%rt0 = getelementptr i8* %rt2, i32 8;
	%rt3 = bitcast i8* %rt0 to i64*;
	%r0 = load i64* %rt3, align 8;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt5 = load i8** %rt4;
	%rt6 = bitcast i8* %rt5 to i64*;
	%r1 = load i64* %rt6, align 8;
	%rt8 = inttoptr i64 %r0 to < 4 x i32 >*;
	%rt7 = load < 4 x i32 >* %rt8, align 16;
	%r2 = extractelement < 4 x i32 > %rt7, i32 0;
	%r3 = extractelement < 4 x i32 > %rt7, i32 1;
	%r4 = extractelement < 4 x i32 > %rt7, i32 2;
	%r5 = extractelement < 4 x i32 > %rt7, i32 3;
	%r6 = bitcast i32 %r3 to i32;
	%r7 = bitcast i32 %r4 to i32;
	%r8 = bitcast i32 %r5 to i32;
	%r9 = bitcast i32 %r2 to i32;
	%rt9 = inttoptr i64 %r1 to < 4 x i32 >*;
	%rt10 = insertelement < 4 x i32 > < i32 0, i32 0, i32 0, i32 0 >, i32 %r6, i32 0;
	%rt11 = insertelement < 4 x i32 > %rt10, i32 %r7, i32 1;
	%rt12 = insertelement < 4 x i32 > %rt11, i32 %r8, i32 2;
	%rt13 = insertelement < 4 x i32 > %rt12, i32 %r9, i32 3;
	store < 4 x i32 > %rt13, < 4 x i32 >* %rt9, align 16;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r10 = bitcast i32 0 to i32;
	%rt14 = zext i32 %r10 to i64;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt16 = load i8** %rt15;
	%rt17 = ptrtoint i8* %rt16 to i64;
	%rt18 = add i64 %rt14, %rt17;
	%rt19 = inttoptr i64 %rt18 to i32*;
	store i32 6, i32* %rt19, align 4;
	br label %exit;
exit:
	ret void;

}

(0.006435) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.006444) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.006451) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.006584) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_test_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_1_0002":
  %rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt2 = load i8** %rt1
  %rt0 = getelementptr i8* %rt2, i32 8
  %rt3 = bitcast i8* %rt0 to i64*
  %r0 = load i64* %rt3, align 8
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt5 = load i8** %rt4
  %rt6 = bitcast i8* %rt5 to i64*
  %r1 = load i64* %rt6, align 8
  %rt8 = inttoptr i64 %r0 to <4 x i32>*
  %rt7 = load <4 x i32>* %rt8, align 16
  %r2 = extractelement <4 x i32> %rt7, i32 0
  %r3 = extractelement <4 x i32> %rt7, i32 1
  %r4 = extractelement <4 x i32> %rt7, i32 2
  %r5 = extractelement <4 x i32> %rt7, i32 3
  %r6 = bitcast i32 %r3 to i32
  %r7 = bitcast i32 %r4 to i32
  %r8 = bitcast i32 %r5 to i32
  %r9 = bitcast i32 %r2 to i32
  %rt9 = inttoptr i64 %r1 to <4 x i32>*
  %rt10 = insertelement <4 x i32> zeroinitializer, i32 %r6, i32 0
  %rt11 = insertelement <4 x i32> %rt10, i32 %r7, i32 1
  %rt12 = insertelement <4 x i32> %rt11, i32 %r8, i32 2
  %rt13 = insertelement <4 x i32> %rt12, i32 %r9, i32 3
  store <4 x i32> %rt13, <4 x i32>* %rt9, align 16
  br i1 true, label %"$BB_1_0002_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; preds = %"$BB_1_0002"
  %r10 = bitcast i32 0 to i32
  %rt14 = zext i32 %r10 to i64
  %rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt16 = load i8** %rt15
  %rt17 = ptrtoint i8* %rt16 to i64
  %rt18 = add i64 %rt14, %rt17
  %rt19 = inttoptr i64 %rt18 to i32*
  store i32 6, i32* %rt19, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002_exit", %"$BB_1_0002"
  ret void
}



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTexture2D 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDeviceSwitching
INFO     Test completed in 0.0411338806152 seconds
INFO      It produced the following output:
(0.001687) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - simpleKernels
(0.001712) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'increment'
(0.002906) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.002914) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_increment( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt1 = load i8** %rt0;
	%rt2 = bitcast i8* %rt1 to i64*;
	%r0 = load i64* %rt2, align 8;
	%rt3 = inttoptr i64 %r0 to i32*;
	%r1 = load i32* %rt3, align 4;
	%r2 = add i32 %r1, 1;
	%rt4 = inttoptr i64 %r0 to i32*;
	store i32 %r2, i32* %rt4, align 4;
	br label %$BB_1_0003;
$BB_1_0003:
	br i1 1, label %$BB_1_0003_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0003_entry:
	br label %$BB_1_0003;
$BB_1_0002_exit:
	ret void;
$BB_1_0003_exit:
	%r3 = bitcast i32 0 to i32;
	%rt5 = zext i32 %r3 to i64;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt7 = load i8** %rt6;
	%rt8 = ptrtoint i8* %rt7 to i64;
	%rt9 = add i64 %rt5, %rt8;
	%rt10 = inttoptr i64 %rt9 to i32*;
	store i32 6, i32* %rt10, align 4;
	br label %exit;
exit:
	ret void;

}

(0.003916) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.003925) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.003932) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.004066) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_increment_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_1_0002":
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt1 = load i8** %rt0
  %rt2 = bitcast i8* %rt1 to i64*
  %r0 = load i64* %rt2, align 8
  %rt3 = inttoptr i64 %r0 to i32*
  %r1 = load i32* %rt3, align 4
  %r2 = add i32 %r1, 1
  %rt4 = inttoptr i64 %r0 to i32*
  store i32 %r2, i32* %rt4, align 4
  br label %"$BB_1_0003"

"$BB_1_0003":                                     ; preds = %"$BB_1_0003_entry", %"$BB_1_0002"
  br i1 true, label %"$BB_1_0003_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0003_entry":                               ; No predecessors!
  br label %"$BB_1_0003"

"$BB_1_0002_exit":                                ; No predecessors!
  ret void

"$BB_1_0003_exit":                                ; preds = %"$BB_1_0003"
  %r3 = bitcast i32 0 to i32
  %rt5 = zext i32 %r3 to i64
  %rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt7 = load i8** %rt6
  %rt8 = ptrtoint i8* %rt7 to i64
  %rt9 = add i64 %rt5, %rt8
  %rt10 = inttoptr i64 %rt9 to i32*
  store i32 6, i32* %rt10, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0003_exit", %"$BB_1_0003"
  ret void
}



INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestConvergence 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLexer
INFO     Test completed in 0.0304682254791 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestLexer

Description: Tests for the PTX lexer. Test Point 1: Scan a PTX file and 
             write out a temp stream, scan the stream again and make sure that the 
             two sets of tokens match


Test Seed : 1315344563
Test time : 1.16825e-05

Status : 


INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestIndirectFunctionCall 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaMalloc
INFO     Test completed in 0.0635681152344 seconds
INFO      It produced the following output:
test_malloc(256, 128)
PASSED
test_mallocArray(256, 128)
checking results from last cudaMemcpyFromArray
PASSED
[1] mallocing pitch
[2] memcpying2d
[3] memcpying
[4] checking for errors
[5] mallocing
[6] memcpying
[7] memcpying
[8] final free
Pass/Fail : Pass

INFO     Running test program /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestKernels 
INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTexture2D
INFO     Test completed in 0.0356140136719 seconds
INFO      It produced the following output:
(0.002413) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - texture2D.cu
(0.002440) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel '_Z6kernelPfii'
(0.004448) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.004458) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated__Z6kernelPfii( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$OcelotTextureAllocateBlock:
	%integerTexture = alloca i32, i32 4, align 16;
	%floatingPointTexture = alloca float, i32 4, align 16;
	br label %$BB_1_0002;
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0;
	%rt3 = load i32* %rt2;
	%r1 = bitcast i32 %rt3 to i32;
	%r2 = mul i32 %r0, %r1;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1;
	%rt5 = load i32* %rt4;
	%r3 = bitcast i32 %rt5 to i32;
	%rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1;
	%rt7 = load i32* %rt6;
	%r4 = bitcast i32 %rt7 to i32;
	%r5 = mul i32 %r3, %r4;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt9 = load i32* %rt8;
	%r6 = bitcast i32 %rt9 to i32;
	%r7 = add i32 %r6, %r2;
	%rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1;
	%rt11 = load i32* %rt10;
	%r8 = bitcast i32 %rt11 to i32;
	%r9 = add i32 %r8, %r5;
	%r10 = uitofp i32 %r7 to float;
	%r11 = uitofp i32 %r9 to float;
	%r12 = bitcast float 0x0 to float;
	%r13 = bitcast float 0x0 to float;
	call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11);
	%r14 = load float* %floatingPointTexture;
	%rt12 = getelementptr float* %floatingPointTexture, i32 1;
	%r15 = load float* %rt12;
	%rt13 = getelementptr float* %floatingPointTexture, i32 2;
	%r16 = load float* %rt13;
	%rt14 = getelementptr float* %floatingPointTexture, i32 3;
	%r17 = load float* %rt14;
	%r18 = bitcast float %r14 to float;
	%rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt16 = load i8** %rt15;
	%rt17 = bitcast i8* %rt16 to i64*;
	%r19 = load i64* %rt17, align 8;
	%rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt20 = load i8** %rt19;
	%rt18 = getelementptr i8* %rt20, i32 8;
	%rt21 = bitcast i8* %rt18 to i32*;
	%r20 = load i32* %rt21, align 4;
	%r21 = mul i32 %r20, %r9;
	%r22 = add i32 %r7, %r21;
	%r23 = zext i32 %r22 to i64;
	%rt22 = zext i32 %r22 to i64;
	%r24 = mul i64 %rt22, 4;
	%r25 = add i64 %r19, %r24;
	%rt23 = inttoptr i64 %r25 to float*;
	store float %r18, float* %rt23, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r26 = bitcast i32 0 to i32;
	%rt24 = zext i32 %r26 to i64;
	%rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt26 = load i8** %rt25;
	%rt27 = ptrtoint i8* %rt26 to i64;
	%rt28 = add i64 %rt24, %rt27;
	%rt29 = inttoptr i64 %rt28 to i32*;
	store i32 6, i32* %rt29, align 4;
	br label %exit;
exit:
	ret void;

}

(0.005526) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.005535) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.005542) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.005681) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated__Z6kernelPfii_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$OcelotTextureAllocateBlock":
  %integerTexture = alloca i32, i32 4, align 16
  %floatingPointTexture = alloca float, i32 4, align 16
  br label %"$BB_1_0002"

"$BB_1_0002":                                     ; preds = %"$BB_1_0002_entry", %"$OcelotTextureAllocateBlock"
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 0
  %rt1 = load i32* %rt0
  %r0 = bitcast i32 %rt1 to i32
  %rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 0
  %rt3 = load i32* %rt2
  %r1 = bitcast i32 %rt3 to i32
  %r2 = mul i32 %r0, %r1
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 2, i32 1
  %rt5 = load i32* %rt4
  %r3 = bitcast i32 %rt5 to i32
  %rt6 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 1, i32 1
  %rt7 = load i32* %rt6
  %r4 = bitcast i32 %rt7 to i32
  %r5 = mul i32 %r3, %r4
  %rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %rt9 = load i32* %rt8
  %r6 = bitcast i32 %rt9 to i32
  %r7 = add i32 %r6, %r2
  %rt10 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 1
  %rt11 = load i32* %rt10
  %r8 = bitcast i32 %rt11 to i32
  %r9 = add i32 %r8, %r5
  %r10 = uitofp i32 %r7 to float
  %r11 = uitofp i32 %r9 to float
  %r12 = bitcast float 0.000000e+00 to float
  %r13 = bitcast float 0.000000e+00 to float
  call void @__ocelot_tex_2d_ff(float* %floatingPointTexture, %LLVMContext* %__ctaContext, i32 0, float %r10, float %r11)
  %r14 = load float* %floatingPointTexture
  %rt12 = getelementptr float* %floatingPointTexture, i32 1
  %r15 = load float* %rt12
  %rt13 = getelementptr float* %floatingPointTexture, i32 2
  %r16 = load float* %rt13
  %rt14 = getelementptr float* %floatingPointTexture, i32 3
  %r17 = load float* %rt14
  %r18 = bitcast float %r14 to float
  %rt15 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt16 = load i8** %rt15
  %rt17 = bitcast i8* %rt16 to i64*
  %r19 = load i64* %rt17, align 8
  %rt19 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt20 = load i8** %rt19
  %rt18 = getelementptr i8* %rt20, i32 8
  %rt21 = bitcast i8* %rt18 to i32*
  %r20 = load i32* %rt21, align 4
  %r21 = mul i32 %r20, %r9
  %r22 = add i32 %r7, %r21
  %r23 = zext i32 %r22 to i64
  %rt22 = zext i32 %r22 to i64
  %r24 = mul i64 %rt22, 4
  %r25 = add i64 %r19, %r24
  %rt23 = inttoptr i64 %r25 to float*
  store float %r18, float* %rt23, align 4
  br i1 true, label %"$BB_1_0002_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; preds = %"$BB_1_0002"
  %r26 = bitcast i32 0 to i32
  %rt24 = zext i32 %r26 to i64
  %rt25 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt26 = load i8** %rt25
  %rt27 = ptrtoint i8* %rt26 to i64
  %rt28 = add i64 %rt24, %rt27
  %rt29 = inttoptr i64 %rt28 to i32*
  store i32 6, i32* %rt29, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002_exit", %"$BB_1_0002"
  ret void
}



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestIndirectFunctionCall
INFO     Test completed in 0.0387661457062 seconds
INFO      It produced the following output:
(0.003672) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - indirectCall.cu
(0.003695) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'funcQuadruple'
(0.003861) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'kernelEntry'
(0.005307) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'funcPentuple'
(0.005449) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'funcTriple'
(0.005589) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'funcDouble'
(0.006643) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.006651) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_funcQuadruple( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_3_0002:
	%rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt2 = load i8** %rt1;
	%rt0 = getelementptr i8* %rt2, i32 4;
	%rt3 = bitcast i8* %rt0 to i32*;
	%r0 = load i32* %rt3, align 4;
	%r1 = bitcast i32 %r0 to i32;
	%r2 = mul i32 %r1, 4;
	%rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt5 = load i8** %rt4;
	%rt6 = bitcast i8* %rt5 to i32*;
	store i32 %r2, i32* %rt6, align 4;
	%rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt8 = load i8** %rt7;
	%rt9 = bitcast i8* %rt8 to i32*;
	store i32 2, i32* %rt9;
	br label %exit;
$BB_3_0002_entry:
	br label %$BB_3_0002;
$BB_3_0002_exit:
	ret void;
exit:
	ret void;

}

(0.007520) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.007529) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.007535) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.007668) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_funcQuadruple_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_3_0002":
  %rt1 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt2 = load i8** %rt1
  %rt0 = getelementptr i8* %rt2, i32 4
  %rt3 = bitcast i8* %rt0 to i32*
  %r0 = load i32* %rt3, align 4
  %r1 = bitcast i32 %r0 to i32
  %r2 = mul i32 %r1, 4
  %rt4 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt5 = load i8** %rt4
  %rt6 = bitcast i8* %rt5 to i32*
  store i32 %r2, i32* %rt6, align 4
  %rt7 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt8 = load i8** %rt7
  %rt9 = bitcast i8* %rt8 to i32*
  store i32 2, i32* %rt9
  br label %exit

"$BB_3_0002_entry":                               ; No predecessors!
  br label %"$BB_3_0002"

"$BB_3_0002_exit":                                ; No predecessors!
  ret void

exit:                                             ; preds = %"$BB_3_0002"
  ret void
}



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestKernels
INFO     Test completed in 0.0366721153259 seconds
INFO      It produced the following output:
Pass/Fail : Pass


Name : TestKernels

Description: 


Test Seed : 1315344563
Test time : 0.0104196

Status : Test output:
looping kernel succeeded
matrix vector kernel succeeded



INFO     Test /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestConvergence
INFO     Test completed in 0.157824993134 seconds
INFO      It produced the following output:
(0.001943) LLVMDynamicTranslationCache.cpp:157:  LLVMDynamicTranslationCache::loadModule() - TestConvergence.cu
(0.001965) LLVMDynamicTranslationCache.cpp:168:  Encountered kernel 'convergence'
(0.003256) LLVMDynamicTranslationCache.cpp:1071: translated PTX to LLVM
(0.003264) LLVMDynamicTranslationCache.cpp:1072: ; Code assembled by Ocelot LLVMKernel 2.0.896


%LLVMContext = type { %Dimension, %Dimension, %Dimension, %Dimension, i8*, i8*, i8*, i8*, i8*, i8* };
declare default i32 @__ocelot_get_extent( %LLVMContext* , i32  ) align 1;
declare default float @llvm.exp2.f32( float  ) align 1;
declare default float @llvm.log2.f32( float  ) align 1;
declare default float @llvm.sin.f32( float  ) align 1;
declare default float @llvm.cos.f32( float  ) align 1;
declare default double @llvm.sqrt.f64( double  ) align 1;
declare default float @llvm.sqrt.f32( float  ) align 1;
declare default i64 @llvm.ctlz.i64( i64  ) align 1;
declare default i32 @llvm.ctlz.i32( i32  ) align 1;
declare default i16 @llvm.ctlz.i16( i16  ) align 1;
declare default i8 @llvm.ctlz.i8( i8  ) align 1;
declare default i64 @llvm.readcyclecounter(  ) align 1;
declare default i64 @llvm.ctpop.i64( i64  ) align 1;
declare default i32 @llvm.ctpop.i32( i32  ) align 1;
declare default i16 @llvm.ctpop.i16( i16  ) align 1;
declare default i8 @llvm.ctpop.i8( i8  ) align 1;
declare default i64 @llvm.atomic.cmp.swap.i64.p0i64( i64* , i64 , i64  ) align 1;
declare default i32 @llvm.atomic.cmp.swap.i32.p0i32( i32* , i32 , i32  ) align 1;
declare default i64 @llvm.atomic.swap.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umax.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.max.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.umin.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.min.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.xor.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.or.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.and.i64.p0i64( i64* , i64  ) align 1;
declare default i64 @llvm.atomic.load.add.i64.p0i64( i64* , i64  ) align 1;
declare default i32 @llvm.atomic.swap.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umax.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.max.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.umin.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.min.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.xor.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.or.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.and.i32.p0i32( i32* , i32  ) align 1;
declare default i32 @llvm.atomic.load.add.i32.p0i32( i32* , i32  ) align 1;
declare default i64 @__ocelot_mul_hi_s64( i64 , i64  ) align 1;
declare default i64 @__ocelot_mul_hi_u64( i64 , i64  ) align 1;
declare default i32* @__ocelot_txq( %LLVMContext* , i32 , i32  ) align 1;
declare default i32 @__ocelot_atomic_dec_32( i64 , i32  ) align 1;
declare default i32 @__ocelot_atomic_inc_32( i64 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fs( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_fu( float* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_ff( float* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_sf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_uf( i32* , %LLVMContext* , i32 , float , float , float , float  ) align 1;
declare default void @__ocelot_tex_3d_ss( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_su( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_us( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_3d_uu( i32* , %LLVMContext* , i32 , i32 , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fs( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_fu( float* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_ff( float* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_sf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_uf( i32* , %LLVMContext* , i32 , float , float  ) align 1;
declare default void @__ocelot_tex_2d_ss( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_su( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_us( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_2d_uu( i32* , %LLVMContext* , i32 , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fs( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_fu( float* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_ff( float* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_sf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_uf( i32* , %LLVMContext* , i32 , float  ) align 1;
declare default void @__ocelot_tex_1d_ss( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_su( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_us( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default void @__ocelot_tex_1d_uu( i32* , %LLVMContext* , i32 , i32  ) align 1;
declare default i1 @__ocelot_vote( i1 , i32 , i1  ) align 1;
declare default i32 @__ocelot_prmt_rc16( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecr( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_ecl( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_rc8( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_b4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt_f4e( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_prmt( i32 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfind_b64( i64 , i1  ) align 1;
declare default i32 @__ocelot_bfind_b32( i32 , i1  ) align 1;
declare default i64 @__ocelot_bfi_b64( i64 , i64 , i32 , i32  ) align 1;
declare default i32 @__ocelot_bfi_b32( i32 , i32 , i32 , i32  ) align 1;
declare default i64 @__ocelot_brev_b64( i64  ) align 1;
declare default i32 @__ocelot_brev_b32( i32  ) align 1;

%Dimension = type { i32, i32, i32 };
define default void @_Z_ocelotTranslated_convergence( %LLVMContext* %__ctaContext ) nounwind align 1;
{
$BB_1_0002:
	%rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0;
	%rt1 = load i32* %rt0;
	%r0 = bitcast i32 %rt1 to i32;
	%r1 = sitofp i32 %r0 to float;
	%r2 = fadd float %r1, %r1;
	%r3 = bitcast float 0x3ff0000000000000 to float;
	%r4 = fadd float %r2, %r3;
	%rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8;
	%rt3 = load i8** %rt2;
	%rt4 = bitcast i8* %rt3 to i64*;
	%r5 = load i64* %rt4, align 8;
	%r6 = sext i32 %r0 to i64;
	%rt5 = sext i32 %r0 to i64;
	%r7 = mul i64 %rt5, 4;
	%r8 = add i64 %r5, %r7;
	%rt6 = inttoptr i64 %r8 to float*;
	store float %r4, float* %rt6, align 4;
	br i1 1, label %$BB_1_0002_exit, label %exit;
$BB_1_0002_entry:
	br label %$BB_1_0002;
$BB_1_0002_exit:
	%r9 = bitcast i32 0 to i32;
	%rt7 = zext i32 %r9 to i64;
	%rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4;
	%rt9 = load i8** %rt8;
	%rt10 = ptrtoint i8* %rt9 to i64;
	%rt11 = add i64 %rt7, %rt10;
	%rt12 = inttoptr i64 %rt11 to i32*;
	store i32 6, i32* %rt12, align 4;
	br label %exit;
exit:
	ret void;

}

(0.004171) LLVMDynamicTranslationCache.cpp:1411: cloning source module
(0.004179) LLVMDynamicTranslationCache.cpp:1417:   cloning variables
(0.004186) LLVMDynamicTranslationCache.cpp:1434:   cloning functions
(0.004317) LLVMDynamicTranslationCache.cpp:1445:   done
Cloned function:

define internal void @_Z_ocelotTranslated_convergence_opt3_ws1(%LLVMContext* %__ctaContext) nounwind align 1 {
"$BB_1_0002":
  %rt0 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 0, i32 0
  %rt1 = load i32* %rt0
  %r0 = bitcast i32 %rt1 to i32
  %r1 = sitofp i32 %r0 to float
  %r2 = fadd float %r1, %r1
  %r3 = bitcast float 1.000000e+00 to float
  %r4 = fadd float %r2, %r3
  %rt2 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 8
  %rt3 = load i8** %rt2
  %rt4 = bitcast i8* %rt3 to i64*
  %r5 = load i64* %rt4, align 8
  %r6 = sext i32 %r0 to i64
  %rt5 = sext i32 %r0 to i64
  %r7 = mul i64 %rt5, 4
  %r8 = add i64 %r5, %r7
  %rt6 = inttoptr i64 %r8 to float*
  store float %r4, float* %rt6, align 4
  br i1 true, label %"$BB_1_0002_exit", label %exit

"$BB_1_0002_entry":                               ; No predecessors!
  br label %"$BB_1_0002"

"$BB_1_0002_exit":                                ; preds = %"$BB_1_0002"
  %r9 = bitcast i32 0 to i32
  %rt7 = zext i32 %r9 to i64
  %rt8 = getelementptr %LLVMContext* %__ctaContext, i32 0, i32 4
  %rt9 = load i8** %rt8
  %rt10 = ptrtoint i8* %rt9 to i64
  %rt11 = add i64 %rt7, %rt10
  %rt12 = inttoptr i64 %rt11 to i32*
  store i32 6, i32* %rt12, align 4
  br label %exit

exit:                                             ; preds = %"$BB_1_0002_exit", %"$BB_1_0002"
  ret void
}



INFO     
Passing tests:
 (0.043s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCalVectorScale : Passed
 (0.037s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestKernels : Passed
 (0.040s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestInstructions : Passed
 (0.033s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDataflowGraph : Passed
 (0.030s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLexer : Passed
 (0.028s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXToLLVMTranslator : Passed
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestEmulator : Passed
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMInstructions : Passed
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestParser : Passed
 (0.064s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaMalloc : Passed

Failing tests:
 (0.039s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestPTXAssembly : Did not complete.
 (0.041s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestDeviceSwitching : Did not complete.
 (0.158s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestConvergence : Did not complete.
 (0.039s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestIndirectFunctionCall : Did not complete.
 (0.043s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaGlobals : Did not complete.
 (0.056s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestLLVMKernels : Did not complete.
 (0.039s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTextureArray : Did not complete.
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaTexture2D : Did not complete.
 (0.064s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestCudaSequence : Did not complete.
 (0.036s) : /home/andrew/repositories/gpuocelot/branch/ocelot-vector-ptx2.1/TestFunctionCall : Did not complete.

